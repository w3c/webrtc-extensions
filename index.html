<!DOCTYPE html>
<html lang="en" dir="ltr">
<head>
  <meta charset="utf-8">
  <link href="webrtc.css" rel="stylesheet">
  <title>WebRTC Extensions</title>
  <script class="remove" src="https://www.w3.org/Tools/respec/respec-w3c"></script>
  <script class="remove" src="webrtc-extensions.js" ></script>
</head>
<body>
  <section id="abstract">
    <p>
      This document defines a set of ECMAScript APIs in WebIDL to extend the WebRTC 1.0 API.
    </p>
  </section>
  <section id="sotd">
    <p>The API is based on preliminary work done in the W3C WEBRTC Working Group.</p>
  </section>
  <section class="informative" id="intro">
    <h2>Introduction</h2>
    <p>
      This document contains proposed extensions to the [[WEBRTC]] specification.
      Some of these extensions were originally included within the [[WEBRTC]] specification,
      but needed to be removed due to lack of implementation experience. Others were not
      sufficiently mature to be incorporated into that specification when they were developed,
      but were too small to warrant creation of a separate document.
    </p>
    <p>
      This document contains some sections extending one specific interface or dictionary in
      the base specification; in this case the extension is only described in an individual
      section. Where an extension affects multiple interfaces or dictionaries, a subsection
      in the "Overviews" section describes the extension as a whole, while normative text
      is provided in sections relating to the individual interfaces.
    </p>
    <p>
      As extensions mature and gain implementation experience, they may move from this document
      to the base specification if WG consensus emerges to do so.
    </p>
  </section>
  <section id="conformance">
    <p>This specification defines conformance criteria that apply to a single
    product: the <dfn>user agent</dfn> that implements the interfaces that it
    contains.</p>
    <p>Conformance requirements phrased as algorithms or specific steps may be
    implemented in any manner, so long as the end result is equivalent. (In
    particular, the algorithms defined in this specification are intended to be
    easy to follow, and not intended to be performant.)</p>
    <p>Implementations that use ECMAScript to implement the APIs defined in
    this specification MUST implement them in a manner consistent with the
    ECMAScript Bindings defined in the Web IDL specification [[WEBIDL]], as
    this specification uses that specification and terminology.</p>
  </section>
  <section>
    <h2>Terminology</h2>
    <p>
      The following terms are defined in
      <dfn data-cite="RTP-EXT-CAPTURE-TIME#">RTP Header Extension for Absolute Capture Time</dfn>:
    </p>
    <ul>
      <li><dfn data-cite="RTP-EXT-CAPTURE-TIME#absolute-capture-timestamp">absolute capture timestamp</dfn></li>
      <li><dfn data-cite="RTP-EXT-CAPTURE-TIME#timestamp-interpolation">timestamp interpolation</dfn></li>
      <li><dfn data-cite="RTP-EXT-CAPTURE-TIME#estimated-capture-clock-offset">estimated capture clock offset</dfn></li>
    </ul>
    <p>
      The process of <dfn data-lt="form|formed|forming">forming</dfn> a candidate pair is defined in
      [[RFC8445]] Section 6.1.2.2.
    </p>
    <p>
      The process of <dfn data-lt="nominate|nominated|nomination">nominating</dfn> a candidate pair is defined in
      [[RFC8445]] Section 8.1.1.
    </p>
    <p>
      The process of <dfn data-lt="free|freed|freeing">freeing</dfn> a candidate is defined in [[RFC8445]] Section 8.3.
    </p>
  </section>
  <section id="ice-csp">
    <h3>
      Filtering ICE candidates with Content-Security-Policy
    </h3>
    <p>
      The {{RTCPeerConnection}} interface is defined in [[WEBRTC]]. This document
      extends that interface by using Content-Security-Policy for ICE candidate
      filtering.
    </p>
    <section id="ice-csp-modifications">
      <h2>Modifications to existing procedures</h2>

      <p>Append the following paragraph to the
      <a data-cite="WEBRTC#dfn-administratively-prohibited">administratively prohibited</a>
      algorithm:</p>

      <p>If <a data-cite="CSP#should-block-rtc-connection">
        should RTC connections be blocked for global?</a> with the
      [=relevant global object=] of the {{RTCPeerConnection}} object in question
      returns `"Blocked"`, then all candidates MUST be <a
        data-cite="WEBRTC#dfn-administratively-prohibited">
        administratively prohibited</a>.</p>
    </section>
  </section>
  <section id="rtp-header-extension-control">
    <h2>RTP header extension control</h2>
    <p>
      RTP header extension control is an extension to {{RTCRtpTransceiver}} that allows
      to set and query the RTP header extensions supported and negotiated in SDP.
    <p>
      The RTP header extension mechanism is defined in [[RFC8285]], with
      the SDP negotiation mechanism defined in section 5. It goes into some
      detail on the meaning of "direction" with regard to RTP header
      extensions, and gives a detailed procedure for negotiating RTP header
      extension IDs.
    </p>
    <p>
      This API extension gives the means to control the use and direction of
      RTP header extensions as documented in [[RFC8285]]. It does not
      influence the ID negotiation mechanism, except for being able to
      control the number of extensions offered.
    </p>
    <section id="rtp-header-extension-control-transceiver-interface">
      <h3>
        {{RTCRtpTransceiver}} interface extensions
      </h3>
      <p>
        The {{RTCRtpTransceiver}}
        interface is defined in [[WEBRTC]]. This document extends that interface
        by adding an additional method and attribute in order to control negotiation of
        RTP header extensions.
      </p>
      <pre class="idl">
partial dictionary RTCRtpHeaderExtensionCapability {
  required RTCRtpTransceiverDirection direction;
};

partial interface RTCRtpTransceiver {
  sequence&lt;RTCRtpHeaderExtensionCapability&gt; getHeaderExtensionsToNegotiate();
  undefined setHeaderExtensionsToNegotiate(
      sequence&lt;RTCRtpHeaderExtensionCapability&gt; extensions);
  sequence&lt;RTCRtpHeaderExtensionCapability&gt; getNegotiatedHeaderExtensions();
};
      </pre>
      <p>
        Let
        <dfn data-dfn-for=RTCRtpTransceiver>{{RTCRtpTransceiver/[[HeaderExtensionsToNegotiate]]}}</dfn>
        and
        <dfn data-dfn-for=RTCRtpTransceiver>{{RTCRtpTransceiver/[[NegotiatedHeaderExtensions]]}}</dfn>
        be internal slots of the {{RTCRtpTransceiver}}, initialized as follows:
      </p>
      <ol>
        <li>
          <p>Set {{RTCRtpTransceiver/[[HeaderExtensionsToNegotiate]]}} to the
          platform-specific list of implemented RTP header extensions. The
          {{RTCRtpHeaderExtensionCapability/direction}} attribute for all
          extensions that are mandatory to use MUST be initialized to an
          appropriate value other than {{RTCRtpTransceiverDirection/"stopped"}}.
          The {{RTCRtpHeaderExtensionCapability/direction}} attribute for
          extensions that will not be offered by default in an initial offer MUST
          be initialized to {{RTCRtpTransceiverDirection/"stopped"}}.</p>
          <p class="note">The list of header extensions that MUST/SHOULD be
          supported is listed in [[RTCWEB-RTP]], section 5.2. The "mid" extension
          is mandatory to use when BUNDLE is in use, per [[BUNDLE]] section
          9.1.</p>
        </li>
        <li>
          <p>Set {{RTCRtpTransceiver/[[NegotiatedHeaderExtensions]]}} to an empty
          list.</p>
        </li>
      </ol>
    </section>
    <section id="rtp-header-extension-control-modifications">
      <h2>Modifications to existing procedures</h2>
      <p>
        Make the following modifications to the
        <a data-cite="WEBRTC#set-description">set a session description</a>
        algorithm:
      </p>
      <ul>
        <li>
          <p>In the step for processing a <var>description</var> of type
          {{RTCSdpType/"answer"}} that runs for both local and remote
          descriptions, insert the following steps:</p>
          <ol>
            <li>
              <p>For each <var>media description</var> and corresponding
              <var>transceiver</var>, let <var>negotiatedExtensions</var> be the
              value of
              <var>transceiver</var>.{{RTCRtpTransceiver/[[HeaderExtensionsToNegotiate]]}}.</p>
            </li>
            <li>
              <p>For each <var>extension</var> in
              <var>negotiatedExtensions</var>, run the following steps:</p>
              <ol>
                <li>
                  <p>Let <var>answeredDirection</var> be the direction attribute
                  of the "a=extmap" line in the answer's
                  <var>media description</var> that correspond to this
                  <var>extension</var> if one exists, otherwise set
                  <var>answeredDirection</var> to
                  {{RTCRtpTransceiverDirection/"stopped"}}.</p>
                </li>
                <li>
                  <p>If <var>description</var> is a remote description, reverse
                  <var>answeredDirection</var> to represent the peer's point of
                  view.</p>
                </li>
                <li>
                  <p>Set
                  <var>extension</var>.{{RTCRtpHeaderExtensionCapability/direction}}
                  to <var>answeredDirection</var>.</p>
                </li>
              </ol>
            </li>
            <li>
              <p>Set
              <var>transceiver</var>.{{RTCRtpTransceiver/[[NegotiatedHeaderExtensions]]}}
              to <var>negotiatedExtensions</var>.</p>
            </li>
          </ol>
        </li>
      </ul>
      <p>
        In the algorithms for generating initial offers in [[RTCWEB-JSEP]] section 5.2.1,
        replace "for each supported RTP header extension, an "a=extmap" line, as specified in
        [[RFC5285]], section 5" " with "For each RTP header extension "e"
        listed in {{RTCRtpTransceiver/[[HeaderExtensionsToNegotiate]]}} where {{RTCRtpHeaderExtensionCapability/direction}} is not {{RTCRtpTransceiverDirection/"stopped"}}, an "a=extmap"
        line, as specified in [[RFC5285]], section 5, with direction taken from "e"'s {{RTCRtpHeaderExtensionCapability/direction}}
        attribute."
      </p>
      <p>
        In the algorithm for generating subsequent offers in [[RTCWEB-JSEP]] section 5.2.2, replace "The
        RTP header extensions MUST only include those that are present in the most recent answer"
        with "For each RTP header extension listed in {{RTCRtpTransceiver/[[HeaderExtensionsToNegotiate]]}},
        and where {{RTCRtpHeaderExtensionCapability/direction}} is not {{RTCRtpTransceiverDirection/"stopped"}}, generate
        an appropriate "a=extmap" line with "direction" set according to the rules of [[RFC5285]]
        section 6, considering the {{RTCRtpHeaderExtensionCapability/direction}} in {{RTCRtpTransceiver/[[HeaderExtensionsToNegotiate]]}} to indicate the
        answerer's desired usage".
      </p>
      <p>
        In the algorithm for generating initial answers in [[RTCWEB-JSEP]] section 5.3.1, replace "For
        each supported RTP header extension that is present in the offer" with "For each
        supported RTP header extension that is present in the offer and is also present in
        {{RTCRtpTransceiver/[[HeaderExtensionsToNegotiate]]}} with a {{RTCRtpHeaderExtensionCapability/direction}} different from {{RTCRtpTransceiverDirection/"stopped"}},
        set the appropriate direction based on {{RTCRtpHeaderExtensionCapability/direction}} that does not exceed the direction in the offer".
      </p>
      <p class="note">
        Since JSEP does not know about WebRTC internal slots, merging this change requires
        more work on a JSEP revision.
      </p>
    </section>
    <section id="rtp-header-extension-control-transceiver-methods">
      <h3>Methods</h3>
      <dl>
        <dt><dfn data-dfn-for=RTCRtpTransceiver>getHeaderExtensionsToNegotiate</dfn></dt>
        <dd>
          <p>Execute the following steps:</p>
          <ol>
            <li>
              <p>Let <var>transceiver</var> be the {{RTCRtpTransceiver}} that
              this method was invoked on.</p>
            </li>
            <li>
              <p>Return
              <var>transceiver</var>.{{RTCRtpTransceiver/[[HeaderExtensionsToNegotiate]]}}.</p>
            </li>
          </ol>
        </dd>
      </dl>
      <dl>
        <dt><dfn data-dfn-for=RTCRtpTransceiver>setHeaderExtensionsToNegotiate</dfn></dt>
        <dd>
          <p>Execute the following steps:</p>
          <ol>
            <li>
              <p>Let <var>transceiver</var> be the {{RTCRtpTransceiver}} that
              this method was invoked on.</p>
            </li>
            <li>
              <p>Let <var>extensions</var> be the first argument of this
              method.</p>
            </li>
            <li>
              <p>If the size of <var>extensions</var> does not match the size of
              <var>transceiver</var>.{{RTCRtpTransceiver/[[HeaderExtensionsToNegotiate]]}}
              [=exception/throw=] an {{InvalidModificationError}}.
              </p>
            </li>
            <li>
              <p>For each index <var>i</var> of <var>extensions</var>, run the
              following steps:</p>
              <ol>
                <li>
                  <p>Let <var>extension</var> be the <var>i</var>-th element of
                  <var>extensions</var>.</p>
                </li>
                <li>
                  <p>If
                  <var>extension</var>.{{RTCRtpHeaderExtensionCapability/uri}}
                  is not equal to the {{RTCRtpHeaderExtensionCapability/uri}} of
                  the <var>i</var>-th element of
                  <var>transceiver</var>.{{RTCRtpTransceiver/[[HeaderExtensionsToNegotiate]]}},
                  [=exception/throw=] an {{InvalidModificationError}}.</p>
                </li>
                <li>
                  <p>If
                  <var>extension</var>.{{RTCRtpHeaderExtensionCapability/direction}}
                  is not {{RTCRtpTransceiverDirection/"sendrecv"}} and
                  {{RTCRtpHeaderExtensionParameters/uri}} indicates a
                  mandatory-to-use attribute that is required to be both sent
                  and received, [=exception/throw=] an
                  {{InvalidModificationError}}.</p>
                </li>
                <li>
                  <p>If
                  <var>extension</var>.{{RTCRtpHeaderExtensionCapability/direction}}
                  is {{RTCRtpTransceiverDirection/"stopped"}} and
                  {{RTCRtpHeaderExtensionCapability/uri}} indicates a
                  mandatory-to-implement extension, [=exception/throw=] an
                  {{InvalidModificationError}}.</p>
                </li>
                <li>
                  <p>If necessary, restrict
                  <var>extension</var>.{{RTCRtpHeaderExtensionCapability/direction}}
                  as to not exceed the user agent's capabilities for this
                  extension.</p>
                </li>
              </ol>
            </li>
            <li>
              <p>Set
              <var>transceiver</var>.{{RTCRtpTransceiver/[[HeaderExtensionsToNegotiate]]}}
              to <var>extensions</var>.</p>
            </li>
          </ol>
        </dd>
      </dl>
      <dl>
        <dt><dfn data-dfn-for=RTCRtpTransceiver>getNegotiatedHeaderExtensions</dfn></dt>
        <dd>
          <p>Execute the following steps:</p>
          <ol>
            <li>
              <p>Let <var>transceiver</var> be the {{RTCRtpTransceiver}} that
              this method was invoked on.</p>
            </li>
            <li>
              <p>Return
              <var>transceiver</var>.{{RTCRtpTransceiver/[[NegotiatedHeaderExtensions]]}}.</p>
            </li>
          </ol>
        </dd>
      </dl>
    </section>
  </section>
  <section id="rtcrtpencodingparameters">
    <h3>
      RTCRtpEncodingParameters extensions
    </h3>
    <p>
      The {{RTCRtpEncodingParameters}} dictionary is defined in
      [[WEBRTC]]. This document extends that dictionary with
      additional members to control audio packetization.
    </p>
    <pre class="idl">partial dictionary RTCRtpEncodingParameters {
    RTCResolutionRestriction scaleResolutionDownTo;
    unsigned long            ptime;
    boolean                  adaptivePtime = false;
};</pre>
    <section id="rtcrtpencodingparameters-attributes">
      <h2>Dictionary {{RTCRtpEncodingParameters}} Members</h2>
      <dl data-link-for="RTCRtpEncodingParameters" data-dfn-for="RTCRtpEncodingParameters" class="dictionary-members">
        <dt>
          <dfn data-idl>scaleResolutionDownTo</dfn> of type <span class="idlMemberType">{{RTCResolutionRestriction}}</span>
        </dt>
        <dd>
          <p>The maximum dimensions at which to restrict this encoding.</p>
          <p>The default "scale resolution down by" factors (e.g. 4:2:1) are not
          applied when this parameter is used. Instead, frames are either sent
          as-is or they are downscaled by the encoder to uphold the
          restrictions. The encoder will never upscale a frame. In simulcast,
          not upscaling can result in multiple same-sized encodings if the size
          of the frame is smaller than {{scaleResolutionDownTo}}; an encoding is
          not sent if {{scaleResolutionDownTo}} is larger than the frame and
          there exists another {{RTCRtpEncodingParameters/active}} encoding with
          a smaller {{scaleResolutionDownTo}} density resulting in the same
          size.</p>
          <p>When setting parameters, if {{scaleResolutionDownTo}} is specified
          on any encoding, check that the following is true or else throw an
          {{InvalidModificationError}}:</p>
          <ul>
            <li>
              <p>{{scaleResolutionDownTo}} is specified on all encodings and has
              values in both dimensions that are greater than 0.</p>
            </li>
            <li>
              <p>{{RTCRtpEncodingParameters/scaleResolutionDownBy}} is not
              specified on any encoding.</p>
            </li>
          </ul>
        </dd>
        <dt>
          <dfn data-idl>ptime</dfn> of type <span class="idlMemberType">unsigned long</span>
        </dt>
        <dd>
          <p>The preferred duration of media represented by a packet in milliseconds.</p>
            <div class="issue atrisk">
              <p>
                {{RTCRtpEncodingParameters/ptime}} was moved from [[WEBRTC]] to
                this specification due to lack of support from implementers. It is
                therefore marked as a feature at risk.
              </p>
            </div>
        </dd>
        <dt>
          <dfn data-idl>adaptivePtime</dfn> of type <span class="idlMemberType">boolean</span>,
          defaulting to <code>false</code>.
        </dt>
        <dd>
          <p>Indicates whether this encoding MAY dynamically change
          the frame length. If the value is <code>true</code>, the
          <a>user agent</a> MAY use any valid frame length for any of its
          frames, and MAY change this at any time. Valid values are
          multiples of 10ms. If the <code>maxptime</code> attribute
          (defined in [[RFC4566]] Section 6) is specified, that maximum
          applies. If the value is <code>false</code>, the <a>user agent</a>
          MUST use a fixed frame length.</p>
          <p>If {{adaptivePtime}} is set to <code>true</code>,
          {{ptime}} MUST NOT be set; otherwise,
          {{InvalidModificationError}} MUST be [=exception/throw|thrown=].</p>
          <p class="note">Using a longer frame length reduces the
          bandwidth consumption due to overhead, but does so at the cost
          of increased latency. Changing the frame length dynamically
          allows the <a>user agent</a> to adapt its bandwidth allocation strategy
          based on the current network conditions.</p>
        </dd>
      </dl>
    </section>
  </section>
  <section id="rtcresolutionrestriction">
    <h3>
      The {{RTCResolutionRestriction}} dictionary.
    </h3>
    <pre class="idl">dictionary RTCResolutionRestriction {
    unsigned long maxWidth;
    unsigned long maxHeight;
};</pre>
    <section id="rtcresolutionrestriction-attributes">
      <h2>Dictionary {{RTCResolutionRestriction}} Members</h2>
      <dl data-link-for="RTCResolutionRestriction" data-dfn-for="RTCResolutionRestriction" class="dictionary-members">
        <dt>
          <dfn data-idl>maxWidth</dfn> of type <span class="idlMemberType">unsigned long</span>
        </dt>
        <dd>
          <p>The maximum width that frames will be encoded with without getting
          downscaled. The restrictions are orientation agnostic, see note below.
          When scaling is applied, both dimensions of the frame are downscaled
          using the same factor.</p>
        </dd>
        <dt>
          <dfn data-idl>maxHeight</dfn> of type <span class="idlMemberType">unsigned long</span>
        </dt>
        <dd>
          <p>The maximum height that frames will be encoded with without getting
          downscaled. The restrictions are orientation agnostic, see note below.
          When scaling is applied, both dimensions of the frame are downscaled
          using the same factor.</p>
        </dd>
        <p class="note">
          The restrictions being orientation agnostic means that they will
          automatically be adjusted to portrait mode or landscape mode depending
          on the orientation of the frame being restricted. This means that it
          does not matter if 1280x720 or 720x1280 is specified, both always
          result in the exact same scaling factor regardless of the orientation
          of the frame.
        </p>
      </dl>
    </section>
  </section>
  <section id="rtcrtpsender-setparameters-keyframe">
    <h3>
      {{RTCRtpSender}} {{RTCRtpSender/setParameters()}} extensions for requesting the generation of a key frame.
    </h3>
    <p>
      The {{RTCRtpSender}}'s {{RTCRtpSender/setParameters()}} method is defined in
      [[WEBRTC]]. This document extends the optional second argument to request
      generation of a key frame by the encoder.
    </p>
    <pre class="idl">partial dictionary RTCSetParameterOptions {
  sequence&lt;RTCEncodingOptions&gt; encodingOptions = [];
};

dictionary RTCEncodingOptions {
  boolean keyFrame = false;
};</pre>
    <section id="rtcrtpsender-setparameters-keyframe-setparameteroptions-idl">
      <h2>Dictionary {{RTCSetParameterOptions}} Members</h2>
      <p>
        The {{RTCSetParameterOptions}} are extended by a sequence of {{RTCEncodingOptions}}, one for each encoding.
      </p>
      <dl data-link-for="RTCSetParameterOptions" data-dfn-for="RTCSetParameterOptions" class="dictionary-members">
        <dt>
          <dfn data-idl>encodingOptions</dfn> of type <span class="idlMemberType">sequence&lt;{{RTCEncodingOptions}}&gt;</span>, defaulting to <code>[]</code>.
        </dt>
        <dd>
          <p>
            A sequence containing encoding options for each RTP encoding.
          </p>
        </dd>
      </dl>
    </section>
    <section id="rtcrtpsender-setparameters-keyframe-encodingoptions-idl">
      <h2>Dictionary {{RTCEncodingOptions}} Members</h2>
      <p>
        {{RTCEncodingOptions}} is the WebRTC equivalent of {{VideoEncoderEncodeOptions}} in [[WebCodecs]].
      </p>
      <dl data-link-for="RTCEncodingOptions" data-dfn-for="RTCEncodingOptions" class="dictionary-members">
        <dt>
          <dfn data-idl>keyFrame</dfn> of type <span class="idlMemberType">boolean</span>, defaulting to <code>false</code>.
        </dt>
        <dd>
          <p>
            When set to true, request that RTCRtpSender's encoder generates a keyframe for the encoding.
            The semantic of this boolean is similar to the RTCP FIR message described in [RFC5104], section 3.5.1.
          </p>
        </dd>
      </dl>
    </section>
    <section id="rtcrtpsender-setparameters-keyframe-interface-extensions">
      <h2>{{RTCRtpSender}} {{RTCRtpSender/setParameters()}} modifications to existing procedures</h2>
      <p>
        In the steps to call the {{RTCRtpSender/setParameters()}} method,
        let <var>parameters</var> be the method's first argument and let
        <var>setParameterOptions</var> be the method's second argument.
      </p>
      <p>Append the following steps after the steps to validate the <var>parameters</var>:</p>
      <ul>
        <li>
          <p>If the [=RTCRtpTransceiver/transceiver kind=] of the associated kind is `"audio"`, set
          <var>setParameterOptions.encodingOptions</var> to the empty list.</p>
        </li>
        <li>
          <p>If <var>setParameterOptions.encodingOptions</var> is not empty and
          <code><var>setParameterOptions.encodingOptions</var>.length</code> is
          different from <code><var>parameters</var>.encodings.length</code>,
          return a promise [= rejected =] with a newly [= exception/created =] {{InvalidModificationError}}.</p>
        </li>
      </ul>
      <p>In the steps to configure the media stack to use <var>parameters</var>, append the following step:</p>
      <ul>
        <li>
          <p>For each <var>setParameterOptions.encodingOptions</var> indexed by <var>i</var>,
          if <code><var>setParameterOptions.encodingOptions</var>[i].keyFrame</code> is set to <code>true</code>,
          request that the encoder associated with <code><var>parameters</var>.encodings[i]</code> generates a key frame.</p>
        </li>
      </ul>
      <p class="note">
        {{RTCRtpSender/setParameters()}} does not wait for a key frame to be produced by the encoder.
      </p>
    </section>
  </section>
  <section id="rtcicetransport">
    <h3>
      {{RTCIceTransport}} extensions
    </h3>
    <p>
      The {{RTCIceTransport}} interface is defined in [[WEBRTC]]. This document extends that interface to allow an
      application to observe and affect certain actions that an <dfn>ICE agent</dfn> [[RFC5245]] performs.
    </p>
    <p>
      The [= ICE agent =] performs connectivity checks to identify valid candidate pairs on which it is possible to send
      and receive media and data. In order to conclude ICE processing, the [= ICE agent =] {{nominates}} a valid candidate
      pair as the selected candidate pair. Prior to nomination, any valid candidate pair may be used to send and receive data.
      Once
      a candidate pair is nominated successfully, only the selected candidate pair will be used to send and receive data.
      Changing
      the selected candidate pair after a successful nomination requires an ICE restart.
    </p>
    <p>
      When the [= ICE agent =] has [= formed =] a candidate pair, the [= user agent =] MUST [= queue a task =] to <dfn
        id="rtcicetransport-add">add a candidate pair</dfn>:
    </p>
    <ol class="algorithm">
      <li>
        <p>
          Let |connection:RTCPeerConnection| be the {{RTCPeerConnection}} object associated with this [= ICE agent =].
        </p>
      </li>
      <li>
        <p>
          If <var>connection</var>.{{RTCPeerConnection/[[IsClosed]]}} is
          <code>true</code>, abort these steps.
        </p>
      </li>
      <li>
        <p>
          Let |candidatePair:RTCIceCandidatePair| be a new {{RTCIceCandidatePair}} dictionary
          with its {{RTCIceCandidatePair/local}} and {{RTCIceCandidatePair/remote}} members
          initialized to new {{RTCIceCandidate}}s representing the local and remote part of the
          [= formed =] pair respectively.
        </p>
      </li>
      <li>
        <p>
          Let |transport:RTCIceTransport| be the {{RTCIceTransport}} object associated with |candidatePair|.
        </p>
      </li>
      <li>
        <p>
          [=Assert=]: |candidatePair| does not [= candidate pair match | match =] any
          item in |transport|.{{RTCIceTransport/[[CandidatePairs]]}}
        </p>
      </li>
      <li>
        <p>
          [= list/Append =] |candidatePair| to {{RTCIceTransport/[[CandidatePairs]]}}.
        </p>
      </li>
      <li>
        <p>
          [= Fire an event =] named
          {{RTCIceTransport/icecandidatepairadd}} at |transport|, using {{RTCIceCandidatePairEvent}},
          with the {{RTCIceCandidatePairEvent/local}} and {{RTCIceCandidatePairEvent/remote}} attributes
          initialized to the local and remote candidates, respectively, of |candidatePair|.
        </p>
      </li>
    </ol>
    <p>
      When the [= ICE agent =] has picked a candidate pair to {{nominate}} as the selected candidate pair, the [= user
      agent =]
      MUST [= queue a task =] to <dfn id="rtcicetransport-nominate" data-lt="nominate the candidate pair">nominate a
        candidate pair</dfn>:
    </p>
    <ol class="algorithm">
      <li>
        <p>
          Let |connection:RTCPeerConnection| be the {{RTCPeerConnection}} object associated with this [= ICE agent =].
        </p>
      </li>
      <li>
        <p>
          If <var>connection</var>.{{RTCPeerConnection/[[IsClosed]]}} is
          <code>true</code>, abort these steps.
        </p>
      </li>
      <li>
        <p>
          Let |transport:RTCIceTransport| be the {{RTCIceTransport}} object associated with this candidate pair.
        </p>
      </li>
      <li>
        <p>
          Let |candidatePair:RTCIceCandidatePair| be the candidate pair which is being {{nominated}}.
        </p>
      </li>
      <li>
        <p>
          Set |transport|.{{RTCIceTransport/[[ProposalPending]]}} to <code>true</code>.
        </p>
      </li>
      <li>
        <p>
          Let |accepted:boolean| be the result of [= fire an event | firing an event =] named
          {{RTCIceTransport/icecandidatepairnominate}} at |transport|, using {{RTCIceCandidatePairEvent}}, with the
          {{Event/cancelable}} attribute initialized to <code>true</code>, and the {{RTCIceCandidatePairEvent/local}} and
          {{RTCIceCandidatePairEvent/remote}} attributes initialized to the local and remote candidates, respectively, of
          |candidatePair|.
        </p>
      </li>
      <li>
        <p>
          Set |transport|.{{RTCIceTransport/[[ProposalPending]]}} to <code>false</code>.
        </p>
      </li>
      <li>
        <p>
          If |accepted| is <code>false</code>, abort these steps and instruct the [= ICE agent =] to continue to perform connectivity checks.
        </p>
      </li>
      <li>
        <p>
          Otherwise, instruct the [= ICE agent =] to {{nominate}} the candidate pair indicated by |candidatePair|.
        </p>
      </li>
    </ol>
    <p class="note">
      The [= ICE agent =] will continue to send data using |candidatePair| until instructed to use another candidate pair with {{RTCIceTransport/selectCandidatePair}}.
    </p>
    <p>
      When the [= ICE agent =] has picked a candidate pair to remove, the [= user agent =] MUST [= queue a task =] to <dfn
        id="rtcicetransport-remove">remove a candidate pair</dfn>:
    </p>
    <ol class="algorithm">
      <li>
        <p>
          Let |connection:RTCPeerConnection| be the {{RTCPeerConnection}} object associated with this [= ICE agent =].
        </p>
      </li>
      <li>
        <p>
          If <var>connection</var>.{{RTCPeerConnection/[[IsClosed]]}} is
          <code>true</code>, abort these steps.
        </p>
      </li>
      <li>
        <p>
          Let |candidatePair:RTCIceCandidatePair| be the candidate pair which is being removed.
        </p>
      </li>
      <li>
        <p>
          Let |transport:RTCIceTransport| be the {{RTCIceTransport}} object associated with |candidatePair|.
        </p>
      </li>
      <li>
        <p>
          Let |cancelable:boolean| be <code>true</code> if the candidate pair is being removed in order to [= free =] an unused
          candidate, and
          <code>false</code> otherwise.
        </p>
      </li>
      <li>
        <p>
          Set |transport|.{{RTCIceTransport/[[ProposalPending]]}} to <code>true</code>.
        </p>
      </li>
      <li>
        <p>
          Let |accepted:boolean| be the result of [= fire an event | firing an event =] named
          {{RTCIceTransport/icecandidatepairremove}} at |transport|, using {{RTCIceCandidatePairEvent}}, with the
          {{Event/cancelable}} attribute initialized to <var>cancelable</var>, and the {{RTCIceCandidatePairEvent/local}}
          and {{RTCIceCandidatePairEvent/remote}} attributes initialized to the local and remote candidates, respectively,
          of |candidatePair|.
        </p>
      </li>
      <li>
        <p>
          Set |transport|.{{RTCIceTransport/[[ProposalPending]]}} to <code>false</code>.
        </p>
      </li>
      <li>
        <p>
          If |accepted| is <code>false</code>, instruct the [= ICE agent =] to not remove the candidate pair indicated by
          |candidatePair|, and instead continue to send and respond to ICE connectivity checks on the candidate pair as
          before.
        </p>
      </li>
      <li>
        <p>
          Otherwise (if |accepted| is <code>true</code>), run the following steps:
        </p>
        <ol>
          <li>
            <p>
              [= list/Remove =] |candidatePair| from |transport|.{{RTCIceTransport/[[CandidatePairs]]}}.
            </p>
          </li>
          <li>
            <p>
              Instruct the [= ICE agent =] to remove the candidate pair indicated by |candidatePair|.
            </p>
          </li>
        </ol>
      </li>
    </ol>
    <p>
      The {{RTCIceTransport}} object is extended by adding the following internal slots:
    </p>
    <ul>
      <li>
        <dfn data-dfn-for="RTCIceTransport">[[\CandidatePairs]]</dfn> initialized to an empty list.
      </li>
      <li>
        <dfn data-dfn-for="RTCIceTransport">[[\ProposalPending]]</dfn> initialized to <code>false</code>.
      </li>
    </ul>
    <pre class="idl">
        partial interface RTCIceTransport {
          attribute EventHandler onicecandidatepairadd;
          attribute EventHandler onicecandidatepairremove;
          attribute EventHandler onicecandidatepairnominate;
          Promise&lt;undefined&gt; selectCandidatePair(RTCIceCandidatePair candidatePair);
          Promise&lt;undefined&gt; removeCandidatePair(RTCIceCandidatePair candidatePair);
        };</pre>
    <section id="rtcicetransport-attributes">
      <h2>Attributes</h2>
      <dl data-link-for="RTCIceTransport" data-dfn-for="RTCIceTransport" class="attributes">
        <dt>
          <dfn>onicecandidatepairadd</dfn> of type <span class="idlAttrType">{{EventHandler}}</span>
        </dt>
        <dd>
          <p>
            The event type of this event handler is {{icecandidatepairadd}}, and is fired as part of
            the [= add a candidate pair =] algorithm.
          </p>
        </dd>
        <dt>
          <dfn>onicecandidatepairremove</dfn> of type <span class="idlAttrType">{{EventHandler}}</span>
        </dt>
        <dd>
          <p>
            The event type of this event handler is {{icecandidatepairremove}}, and is fired as part of
            the [= remove a candidate pair =] algorithm.
          </p>
        </dd>
        <dt>
          <dfn>onicecandidatepairnominate</dfn> of type <span class="idlAttrType">{{EventHandler}}</span>
        </dt>
        <dd>
          <p>
            The event type of this event handler is {{icecandidatepairnominate}}, and is fired as part
            of the [= nominate a candidate pair =] algorithm.
          </p>
        </dd>
      </dl>
    </section>
    <section id="rtcicetransport-methods">
      <h2>Methods</h2>
      <dl data-link-for="RTCIceTransport" data-dfn-for="RTCIceTransport" class="methods">
        <dt>
          <dfn>selectCandidatePair</dfn>
        </dt>
        <dd>
          <p>
            The {{selectCandidatePair}} method attempts to select a different candidate pair to send data
            over. If successful, data will be sent on the provided candidate pair.
            It is meant to be called after the application defers the {{nomination}} of a candidate pair
            by cancelling the {{RTCIceTransport/icecandidatepairnominate}} event.
          <p>
          <p>
            When this method is invoked, the [= user agent =] MUST run the following steps:
          </p>
          <ol class="algorithm">
            <li>
              <p>
                Let |connection:RTCPeerConnection| be the {{RTCPeerConnection}} object associated with [=this=].
              </p>
            </li>
            <li>
              <p>
                If <var>connection</var>.{{RTCPeerConnection/[[IsClosed]]}} is
                <code>true</code>, [= exception/throw =] an {{InvalidStateError}}.
              </p>
            </li>
            <li>
              <p>
                If [=this=].{{RTCIceTransport/[[ProposalPending]]}} is <code>true</code>, [= exception/throw =] an {{InvalidStateError}}.
              </p>
            </li>
            <li>
              <p>
                If [=this=].{{RTCIceTransport/[[IceTransportState]]}} is either of
                {{RTCIceTransportState/"new"}}, {{RTCIceTransportState/"failed"}} or {{RTCIceTransportState/"closed"}}, [=
                exception/throw =]
                an {{InvalidStateError}}.
              </p>
            </li>
            <li>
              <p>
                Let |candidatePair:RTCIceCandidatePair| be the method's first argument.
              </p>
            </li>
            <li>
              <p>
                If |candidatePair| does not [= candidate pair match | match =] any item in [=this=].
                {{RTCIceTransport/[[CandidatePairs]]}}, [= exception/throw =] a {{NotFoundError}}.
              </p>
            </li>
            <li>
              <p>
                Let |p:Promise| be a new promise.
              </p>
            </li>
            <li>
              <p>
                In parallel, instruct the [= ICE agent =] to use |candidatePair| to send data.
              </p>
              <ol>
                <li>
                  <p>
                    When the [= ICE agent =] has completed selecting |candidatePair|, [= queue a task =] to run the following steps:
                  </p>
                  <ol>
                    <li>
                      <p>
                        Run the [=RTCIceTransport/change the selected candidate pair and state=] steps to update [=this=].{{RTCIceTransport/[[SelectedCandidatePair]]}} and [=this=].{{RTCIceTransport/[[IceTransportState]]}} as necessary and fire any associated events.
                      </p>
                    </li>
                    <li>
                      <p>
                        Resolve <var>p</var>.
                      </p>
                    </li>
                  </ol>
                </li>
              </ol>
            </li>
            <li>
              <p>
                Return <var>p</var>.
              </p>
            </li>
          </ol>
          <p class="note">
            After changing the selected candidate pair, the controlling [= ICE agent =] may attempt to [= nominate the candidate
            pair =] as
            well to conclude ICE processing. The application may cancel the nomination to allow further changes to the selected
            candidate pair.
          </p>
        </dd>
        <dt>
          <dfn>removeCandidatePair</dfn>
        </dt>
        <dd>
          <p>
            The {{removeCandidatePair}} method removes the provided candidate pair. The [= ICE agent =] will stop sending and
            responding to ICE connectivity checks on the removed candidate pair, and it can no longer be used to send data for this
            transport. This method is meant to be called when the application wants to allow the [= ICE agent =] to [= free =]
            candidates that it no longer needs.
          </p>
          <p>
            When this method is invoked, the [= user agent =] MUST run the following steps:
          </p>
          <ol class="algorithm">
            <li>
              <p>
                Let |connection:RTCPeerConnection| be the {{RTCPeerConnection}} object associated with [= this =].
              </p>
            </li>
            <li>
              <p>
                If <var>connection</var>.{{RTCPeerConnection/[[IsClosed]]}} is
                <code>true</code>, [= exception/throw =] an
                {{InvalidStateError}}.
              </p>
            </li>
            <li>
              <p>
                If [= this =].{{RTCIceTransport/[[ProposalPending]]}} is <code>true</code>, [= exception/throw =] an
                {{InvalidStateError}}.
              </p>
            </li>
            <li>
              <p>
                If [= this =].{{RTCIceTransport/[[IceTransportState]]}} is either of {{RTCIceTransportState/"new"}}, {{RTCIceTransportState/"failed"}} or {{RTCIceTransportState/"closed"}}, [= exception/throw =] an {{InvalidStateError}}.
              </p>
            </li>
            <li>
              <p>
                Let |candidatePair:RTCIceCandidatePair| be the method's first argument.
              </p>
            </li>
            <li>
              <p>
                If |candidatePair| does not [= candidate pair match | match =] any item in [=this=].
                {{RTCIceTransport/[[CandidatePairs]]}}, [= exception/throw =] a {{NotFoundError}}.
              </p>
            </li>
            <li>
              <p>
                [= list/Remove =] the item in
                [=this=].{{RTCIceTransport/[[CandidatePairs]]}} that
                [= candidate pair match | matches =] |candidatePair|.
              </p>
            </li>
            <li>
              <p>
                Let |p:Promise| be a new promise.
              </p>
            </li>
            <li>
              <p>
                In parallel, instruct the [= ICE agent =] to remove the candidate pair indicated by <var>candidatePair</var>.
              </p>
              <ol>
                <li>
                  <p>
                    When the [= ICE agent =] has completed the removal, [= queue a task =] to run the following steps:
                  </p>
                  <ol>
                    <li>
                      <p>
                        [= Fire an event =] named {{RTCIceTransport/icecandidatepairremove}} at |transport|, using {{RTCIceCandidatePairEvent}}, with the {{Event/cancelable}} attribute initialized to <code>false</code>, and the {{RTCIceCandidatePairEvent/local}} and {{RTCIceCandidatePairEvent/remote}} attributes initialized to the {{RTCIceCandidatePair/local}} and {{RTCIceCandidatePair/remote}} candidates, respectively, of <var>candidatePair</var>.
                      </p>
                    </li>
                    <li>
                      <p>
                        Resolve <var>p</var>.
                      </p>
                    </li>
                  </ol>
                </li>
              </ol>
            </li>
            <li>
              <p>
                Return <var>p</var>.
              </p>
            </li>
          </ol>
        </dd>
      </dl>
    </section>
    <section>
      <h2>
        <dfn>RTCIceCandidatePairEvent</dfn>
      </h2>
      <p>
        The {{RTCIceTransport/icecandidatepairadd}} and {{RTCIceTransport/icecandidatepairremove}} events use the
        {{RTCIceCandidatePairEvent}} interface.
      </p>
      <div>
        <pre class="idl">[Exposed=Window]
  interface RTCIceCandidatePairEvent : Event {
    constructor(DOMString type, RTCIceCandidatePairEventInit eventInitDict);
    readonly attribute RTCIceCandidate local;
    readonly attribute RTCIceCandidate remote;
  };</pre>
        <section id="rtcicecandidatepairevent-constructors">
          <h4>Constructors</h4>
          <dl data-link-for="RTCIceCandidatePairEvent" data-dfn-for="RTCIceCandidatePairEvent" class="constructors">
            <dt><dfn>RTCIceCandidatePairEvent.constructor()</dfn></dt>
            <dd></dd>
          </dl>
        </section>
        <section id="rtcicecandidatepairevent-attributes">
          <h4>Attributes</h4>
          <dl data-link-for="RTCIceCandidatePairEvent" data-dfn-for="RTCIceCandidatePairEvent" class="attributes">
            <dt>
              <dfn>local</dfn> of type <span class="idlAttrType">{{RTCIceCandidate}}</span>, readonly
            </dt>
            <dd>
              <p>
                The {{local}} attribute represents the local {{RTCIceCandidate}} of the candidate pair associated with the
                event.
              </p>
            </dd>
            <dt>
              <dfn>remote</dfn> of type <span class="idlAttrType">{{RTCIceCandidate}}</span>, readonly
            </dt>
            <dd>
              <p>
                The {{remote}} attribute represents the remote {{RTCIceCandidate}} of the candidate pair associated with
                the event.
              </p>
            </dd>
          </dl>
        </section>
      </div>
      <div>
        <pre class="idl">
  dictionary RTCIceCandidatePairEventInit : EventInit {
    required RTCIceCandidate local;
    required RTCIceCandidate remote;
  };</pre>
        <section id="rtcicecandidatepaireventinit">
          <h4>Dictionary <dfn>RTCIceCandidatePairEventInit</dfn> Members</h4>
          <dl data-link-for="RTCIceCandidatePairEventInit" data-dfn-for="RTCIceCandidatePairEventInit"
            class="dictionary-members">
            <dt>
              <dfn>local</dfn> of type <span class="idlAttrType">{{RTCIceCandidate}}</span>, required
            </dt>
            <dd>
              <p>
                The local {{RTCIceCandidate}} of the candidate pair announced by the event.
              </p>
            </dd>
            <dt>
              <dfn>remote</dfn> of type <span class="idlAttrType">{{RTCIceCandidate}}</span>, required
            </dt>
            <dd>
              <p>
                The remote {{RTCIceCandidate}} of the candidate pair announced by the event.
              </p>
            </dd>
          </dl>
        </section>
      </div>
    </section>
    <p>
      The <dfn>candidate match</dfn> algorithm given two {{RTCIceCandidate}} |first:RTCIceCandidate| and
      |second:RTCIceCandidate| is as follows:
    </p>
    <ol class="algorithm">
      <li>
        <p>
          If |first|.{{RTCIceCandidate/candidate}} is not [= string/identical to =] |second|.{{RTCIceCandidate/candidate}}, return <code>false</code>.
        </p>
      </li>
      <li>
        <p>
          If either (but not both) of |first|.{{RTCIceCandidate/sdpMid}} and |second|.{{RTCIceCandidate/sdpMid}} is
          <code>null</code>, return <code>false</code>.
        </p>
      </li>
      <li>
        <p>
          If neither of |first|.{{RTCIceCandidate/sdpMid}} and |second|.{{RTCIceCandidate/sdpMid}} is <code>null</code>, and |first|.{{RTCIceCandidate/sdpMid}} is not [= string/identical to =]
          |second|.{{RTCIceCandidate/sdpMid}}, return <code>false</code>.
        </p>
      </li>
      <li>
        <p>
          If either (but not both) of |first|.{{RTCIceCandidate/sdpMLineIndex}} and |second|.{{RTCIceCandidate/sdpMLineIndex}} is
          <code>null</code>, return <code>false</code>.
        </p>
      </li>
      <li>
        <p>
          If neither of |first|.{{RTCIceCandidate/sdpMLineIndex}} and |second|.{{RTCIceCandidate/sdpMLineIndex}} is <code>null</code> and |first|.{{RTCIceCandidate/sdpMLineIndex}} is not equal to
          |second|.{{RTCIceCandidate/sdpMLineIndex}}, return <code>false</code>.
        </p>
      </li>
      <li>
        <p>
          If either (but not both) of |first|.{{RTCIceCandidate/usernameFragment}} and |second|.{{RTCIceCandidate/usernameFragment}} is
          <code>null</code>, return <code>false</code>.
        </p>
      </li>
      <li>
        <p>
          If neither of |first|.{{RTCIceCandidate/usernameFragment}} and |second|.{{RTCIceCandidate/usernameFragment}} is <code>null</code> and |first|.{{RTCIceCandidate/usernameFragment}} is not [= string/identical to =]
          |second|.{{RTCIceCandidate/usernameFragment}}, return <code>false</code>.
        </p>
      </li>
      <li>
        <p>
          Return <code>true</code>.
        </p>
      </li>
    </ol>
    <p>
      The <dfn>candidate pair match</dfn> algorithm given two {{RTCIceCandidatePair}} |first:RTCIceCandidatePair| and |second:RTCIceCandidatePair| is as follows:
    </p>
    <ol class="algorithm">
      <li>
        <p>
          If |first|.{{RTCIceCandidatePair/local}} does not [= candidate match | match =] |second|.{{RTCIceCandidatePair/local}}, return <code>false</code>.
        </p>
      </li>
      <li>
        <p>
          If |first|.{{RTCIceCandidatePair/remote}} does not [= candidate match | match =] |second|.{{RTCIceCandidatePair/remote}}, return <code>false</code>.
        </p>
      </li>
      <li>
        <p>
          Return <code>true</code>.
        </p>
      </li>
    </ol>
  </section>
  <section id="rtcrtpcontributingsource-extensions">
    <h3>
      {{RTCRtpContributingSource}} extensions
    </h3>
    <p>
      The {{RTCRtpContributingSource}} dictionary is defined in [[WEBRTC]]. This
      document extends that dictionary by adding two additional members.
    </p>
    <p>
      In this section, the <dfn>capture system</dfn> refers to the system where
      media is sourced from and the <dfn>sender system</dfn> refers to the
      system that is sending RTP and RTCP packets to the
      <dfn>receiver system</dfn> where {{RTCRtpContributingSource}} data is
      populated.
    </p>
    <p>
      In a direct connection, the <a>capture system</a> is the same as the
      <a>sender system</a>. But when one or more RTCP-terminating intermediate
      systems (e.g. mixers) are involved this is not the case. In such cases,
      media is sourced from the <a>capture system</a>, may be relayed through a
      number of intermediate systems and is then finally sent from the
      <a>sender system</a> to the <a>receiver system</a>. The
      <a>sender system</a>-<a>receiver system</a> path only represents the
      "last hop".
    </p>
    <p>
      Despite {{RTCRemoteInboundRtpStreamStats.roundTripTime}}
      measurements only accounting for the "last hop", one-way delay from the
      [=capture system=]'s time of capture to the [=receiver system=]'s
      time of playout can be estimated if the
      [=RTP Header Extension for Absolute Capture Time=] is used all hops of
      the way, where each RTCP-terminating intermediate system appropriately
      updates the [=estimated capture clock offset=].
    </p>
    <pre class="idl">partial dictionary RTCRtpContributingSource {
  DOMHighResTimeStamp captureTimestamp;
  DOMHighResTimeStamp senderCaptureTimeOffset;
};</pre>
    <section id="rtcrtpcontributingsource-attributes">
      <h2>Dictionary {{RTCRtpContributingSource}} Members</h2>
      <dl data-link-for="RTCRtpContributingSource" data-dfn-for="RTCRtpContributingSource" class="dictionary-members">
        <dt><dfn data-idl>captureTimestamp</dfn> of type {{DOMHighResTimeStamp}}.</dt>
        <dd>
          <p>
            The {{captureTimestamp}} is the timestamp that, the most recent frame
            (from an RTP packet originating from this source) delivered to the
            {{RTCRtpReceiver}}'s {{MediaStreamTrack}}, was originally captured.
            Its reference clock is the <a>capture system</a>'s NTP clock (same
            clock used to generate NTP timestamps for RTCP sender reports on that
            system).
          </p>
          <p>
            On populating this member, the <a>user agent</a> MUST run the following
            steps:
          </p>
          <ol>
            <li>
              <p>If the relevant RTP packet contains the
              <a>RTP Header Extension for Absolute Capture Time</a>, return the
              value of the <a>absolute capture timestamp</a> field and abort
              these steps.</p>
            </li>
            <li>
              <p>Otherwise, if the relevant RTP packet does not contain the
              <a>RTP Header Extension for Absolute Capture Time</a> but a
              previous RTP packet did, return the result of calculating the
              absolute capture timestamp according to
              <a>timestamp interpolation</a> and abort these steps.</p>
            </li>
            <li>
              Otherwise, return <code>undefined</code>.
            </li>
          </ol>
          <p class="note">
            If multiple receiving tracks are sourced from the same
            <a>capture system</a>, two {{captureTimestamp}}s can be used to
            accurately measure audio-video synchronization since both timestamps
            are based on the same system's clock.
          </p>
        </dd>
        <dt><dfn data-idl>senderCaptureTimeOffset</dfn> of type {{DOMHighResTimeStamp}}.</dt>
        <dd>
          <p>
            The {{senderCaptureTimeOffset}} is the <a>sender system</a>'s
            estimate of the offset between its own NTP clock and the
            <a>capture system</a>'s NTP clock, for the same frame that the
            {{captureTimestamp}} was originated from.
          </p>
          <p>
            On populating this member, the <a>user agent</a> MUST run the following
            steps:
          </p>
          <ol>
            <li>
              <p>If the relevant RTP packet contains the
              <a>RTP Header Extension for Absolute Capture Time</a> and the
              <a>estimated capture clock offset</a> field is present, return the
              value of the <a>estimated capture clock offset</a> field and abort
              these steps.</p>
            </li>
            <li>
              <p>Otherwise, if the relevant RTP packet does not contain the
              <a>RTP Header Extension for Absolute Capture Time</a>'s
              <a>estimated capture clock offset</a> field, but a
              previous RTP packet did, return the most recent value that was
              present and abort these steps.</p>
            </li>
            <li>
              Otherwise, return <code>undefined</code>.
            </li>
          </ol>
          <p class="note">
            The time of capture can estimatedly be expressed in the
            <a>sender system</a>'s clock as follows:
            <var>senderCaptureTimestamp</var> = {{captureTimestamp}} +
            {{senderCaptureTimeOffset}}.
          </p>
          <p class="note">
            The offset between the <a>sender system</a>'s clock and the
            <a>receiver system</a>'s clock can be estimated as follows:
            <var>senderReceiverTimeOffset</var> =
            {{RTCRemoteOutboundRtpStreamStats}}.<a class=fixme data-cite="WEBRTC#dom-rtcstats-timestamp">timestamp</a>}} -
            ({{RTCRemoteOutboundRtpStreamStats.remoteTimestamp}} +
            {{RTCRemoteInboundRtpStreamStats.roundTripTime}} / 2).
          </p>
          <p class="note">
            The time of capture can estimatedly be expressed in the
            <a>receiver system</a>'s clock as follows:
            <var>receiverCaptureTimestamp</var> = <var>senderCaptureTimestamp</var> +
            <var>senderReceiverTimeOffset</var>.
          </p>
          <p class="note">
            The one-way delay between the <a>capture system</a>'s time of capture
            and the <a>receiver system</a>'s time of playout can be estimated as
            follows:
            {{RTCRtpContributingSource.timestamp}} -
            <var>receiverCaptureTimestamp</var>.
          </p>
        </dd>
      </dl>
    </section>
  </section>
  <section id="rtcdatachannel-extensions">
    <h3>
      Data Channel Extensions
    </h3>
   <section id="rtcdatachannel-transferable">
     <h3>
       Transferable Data Channels
     </h3>
     <p>This section extends {{RTCDataChannel}} by making it <a data-cite="!HTML/#transferable-objects">transferable</a>.</p>
     <p>This allows sending and receiving messages outside the context the connection was created, for instance in workers or third-party iframes.</p>
      <div>
      <p>The WebIDL changes are the following:
      <pre class="idl">
  [Exposed=(Window,Worker), Transferable]
  partial interface RTCDataChannel {
};</pre>
    </div>
    <div>
      <p>The <a data-cite="WEBRTC#dfn-create-an-rtcdatachannel">create an RTCDataChannel</a> algorithm is updated by adding the following steps after step 4 of the original algorithm:</p>
      <ol>
        <li><p>Initialize <var>channel</var>.`[[IsTransferable]]` to <code>true</code>.</p></li>
        <li><p>Queue a task to run the following step:</p>
          <ol>
            <li><p>Set <var>channel</var>.`[[IsTransferable]]` to <code>false</code>.</p></li>
          </ol>
        </li>
      </ol>
      <p>This task needs to run before any task enqueued by the <a data-cite="WEBRTC#dfn-receive-an-rtcdatachannel-message">receiving messages on a data channel</a> algorithm for <var>channel</var>.
      This ensures that no message is lost during the transfer of a {{RTCDataChannel}}.</p>
    </div>
    <div>The <a data-cite="WEBRTC#datachannel-send">send() algorithm</a> is modified by adding the following step after step 1 of the original algorithm:
      <ol>
        <li><p>Set <var>channel</var>.`[[IsTransferable]]` to <code>false</code>.</p></li>
      </ol>
    </div>
    <div>
      <p>The {{RTCDataChannel}} <a data-cite="!HTML/#transfer-steps">transfer steps</a>, given <var>value</var> and <var>dataHolder</var>, are:</p>
      <ol>
        <li><p>If <var>value</var>.`[[IsTransferable]]` is <code>false</code>, throw a "DataCloneError" DOMException.</p></li>
        <li><p>Set <var>dataHolder</var>.`[[ReadyState]]` to <var>value</var>.<a data-cite="WEBRTC#dfn-readystate">`[[ReadyState]]`</a>.</p></li>
        <li><p>Set <var>dataHolder</var>.`[[DataChannelLabel]]` to <var>value</var>.<a data-cite="WEBRTC#dfn-datachannellabel">`[[DataChannelLabel]]`</a>.</p></li>
        <li><p>Set <var>dataHolder</var>.`[[Ordered]]` to <var>value</var>.<a data-cite="WEBRTC#dfn-ordered">`[[Ordered]]`</a>.</p></li>
        <li><p>Set <var>dataHolder</var>.`[[MaxPacketLifeTime]]` to <var>value</var>.<a data-cite="WEBRTC#dfn-maxpacketlifetime"></a>.`[[MaxPacketLifeTime]]`</p></li>
        <li><p>Set <var>dataHolder</var>.`[[MaxRetransmits]]` to <var>value</var>.<a data-cite="WEBRTC#dfn-maxretransmits">`[[MaxRetransmits]]`</a>.</p></li>
        <li><p>Set <var>dataHolder</var>.`[[DataChannelProtocol]]` to <var>value</var>.<a data-cite="WEBRTC#dfn-datachannelprotocol">`[[DataChannelProtocol]]`</a>.</p></li>
        <li><p>Set <var>dataHolder</var>.`[[Negotiated]]` to <var>value</var>.<a data-cite="WEBRTC#dfn-negotiated">`[[Negotiated]]`</a>.</p></li>
        <li><p>Set <var>dataHolder</var>.`[[DataChannelId]]` to <var>value</var>.<a data-cite="WEBRTC#dfn-datachannelid">`[[DataChannelId]]`</a>.</p></li>
        <li><p>Set <var>dataHolder</var>.`[[underlyingDataTransport]]` to <var>value</var> <a data-cite="WEBRTC#dfn-data-transport">underlying data transport</a>.</p></li>
        <li><p>Set <var>value</var>.`[[IsTransferable]]` to <code>false</code>.</p></li>
        <li><p>Set <var>value</var>.`[[ReadyState]]` to <a data-cite="WEBRTC/#dom-rtcdatachannelstate-closed">"closed"</a>.</p></li>
      </ol>
    </div>
    <div><p>The {{RTCDataChannel}} [=transfer-receiving steps=], given <var>dataHolder</var> and <var>channel</var>, are:</p>
      <ol>
        <li><p>Initialize <var>channel</var>.<a data-cite="WEBRTC#dfn-readystate">`[[ReadyState]]`</a> to <var>dataHolder</var>.`[[ReadyState]]`.</p></li>
        <li><p>Initialize <var>channel</var>.<a data-cite="WEBRTC#dfn-datachannellabel">`[[DataChannelLabel]]`</a> to <var>dataHolder</var>.`[[\DataChannelLabel]]`.</p></li>
        <li><p>Initialize <var>channel</var>.<a data-cite="WEBRTC#dfn-ordered">`[[Ordered]]`</a> to <var>dataHolder</var>.`[[Ordered]]`.</p></li>
        <li><p>Initialize <var>channel</var>.<a data-cite="WEBRTC#dfn-maxpacketlifetime">`[[MaxPacketLifeTime]]`</a> to <var>dataHolder</var>.`[[MaxPacketLifeTime]]`.</p></li>
        <li><p>Initialize <var>channel</var>.<a data-cite="WEBRTC#dfn-maxretransmits">`[[MaxRetransmits]]`</a> to <var>dataHolder</var>.`[[MaxRetransmits]]`.</p></li>
        <li><p>Initialize <var>channel</var>.<a data-cite="WEBRTC#dfn-datachannelprotocol">`[[DataChannelProtocol]]`</a> to <var>dataHolder</var>.`[[DataChannelProtocol]]`.</p></li>
        <li><p>Initialize <var>channel</var>.<a data-cite="WEBRTC#dfn-negotiated">`[[Negotiated]]`</a> to <var>dataHolder</var>.`[[Negotiated]]`.</p></li>
        <li><p>Initialize <var>channel</var>.<a data-cite="WEBRTC#dfn-datachannelid">`[[DataChannelId]]`</a> to <var>dataHolder</var>.`[[DataChannelId]]`.</p></li>
        <li><p>Initialize <var>channel</var> <a data-cite="WEBRTC#dfn-data-transport">underlying data transport</a> to <var>dataHolder</var>.`[[underlyingDataTransport]]`.</p></li>
      </ol>
      <p>The above steps do not need to transfer <a data-cite="WEBRTC#dfn-readystate">`[[BufferedAmount]]`</a> as its value will always be equal to <code>0</code>.
      The reason is an {{RTCDataChannel}} can be transferred only if its <a data-cite="WEBRTC#datachannel-send">send() algorithm</a> was not called prior the transfer.</p>
      <p>If the <a data-cite="WEBRTC#dfn-data-transport">underlying data transport</a> is closed at the time of the [=transfer-receiving steps=],
      the {{RTCDataChannel}} object will be closed by running the <a data-cite="WEBRTC#announcing-a-data-channel-as-closed">announcing a data channel as closed</a> algorithm immediately after the [=transfer-receiving steps=].</p>
    </div>
  </section>
</section>
  <section id="rtp-header-extension-encryption">
    <h3>RTP Header Extension Encryption</h3>
    <section id="rtp-header-extension-encryption-policy">
      <h3>
          <dfn>RTCRtpHeaderEncryptionPolicy</dfn> Enum
      </h3>
      <p>
        RTP header extension encryption policy affects whether RTP header extension
        encryption is negotiated if the remote endpoint does not support [[RFC9335]].
        If the remote endpoint supports [[RFC9335]], all media streams are sent
        utilizing [[RFC9335]].
      </p>
      <div>
        <pre id="target-rtp-header-encryption-policy" class="idl">enum RTCRtpHeaderEncryptionPolicy {
  "negotiate",
  "require"
};</pre>
        <table data-link-for="RTCRtpHeaderEncryptionPolicy" data-dfn-for=
        "RTCRtpHeaderEncryptionPolicy" class="simple">
          <tbody>
            <tr>
              <th colspan="2">Enumeration description (non-normative)</th>
            </tr>
            <tr>
              <td><dfn data-idl>negotiate</dfn></td>
              <td>
                <p>
                  Negotiate RTP header extension encryption as defined in [[RFC9335]].
                  If encryption cannot be negotiated, RTP header extensions are sent in
                  the clear.
                <p>
              </td>
            </tr>
            <tr>
              <td><dfn data-idl>require</dfn></td>
              <td>
                <p>
                  Require RTP header extension encryption. In [[WEBRTC]] Section 4.4.1.5, add the
                  following check after Step 4.4.4:
                  If <var>remote</var> is <code>true</code>, the <var>connection</var>'s
                  {{RTCRtpHeaderEncryptionPolicy}} is {{RTCRtpHeaderEncryptionPolicy/require}}
                  and the description does not support [[RFC9335]], then [= reject =] <var>p</var>
                  with a newly [= exception/created =] {{InvalidAccessError}} and abort these steps.
                </p>
              </td>
            </tr>
          </tbody>
        </table>
      </div>
    </section>
    <section id="rtp-header-extension-encryption-transceiver-interface">
      <h3>
        {{RTCRtpTransceiver}} interface extensions
      </h3>
        <p>
          {{RTCRtpTransceiver/rtpHeaderEncryptionNegotiated}} defines whether
          the transceiver is sending enrypted RTP header extensions as defined in
          [[RFC9335]].
        </p>
        <pre class="idl">
partial interface RTCRtpTransceiver {
  readonly attribute boolean rtpHeaderEncryptionNegotiated;
};</pre>
      <section>
        <h2>
          Attributes
        </h2>
        <dl data-link-for="RTCRtpTransceiver" data-dfn-for=
        "RTCRtpTransceiver" class="attributes">
          <dt>
            <dfn id="dom-rtptransceiver-rtpHeaderEncryptionNegotiated">rtpHeaderEncryptionNegotiated</dfn> of type <span class=
                  "idlAttrType">Boolean</span>, readonly, nullable
          </dt>
          <dd>
            <p>
              The {{rtpHeaderEncryptionNegotiated}} attribute indicates whether [[RFC9335]] has been
              negotiated.  On getting, the attribute MUST
              return the value of the {{RTCRtpTransceiver/[[RtpHeaderEncryptionNegotiated]]}} slot.
              In [[WEBRTC]] Section 5.4, add the following step to "create an {{RTCRtpTransceiver}}":
              Let <var>transceiver</var> have a <dfn data-dfn-for="RTCRtpTransceiver">[[\RtpHeaderEncryptionNegotiated]]</dfn>
              internal slot, initialized to <code>false</code>.
            </p>
          </dd>
        </dl>
      </section>
    </section>
    <section id="configuration">
      <h3>
        {{RTCConfiguration}} extensions
      </h3>
      <p>
        {{RTCConfiguration/rtpHeaderEncryptionPolicy}} defines the
        policy for negotiation of RTP header encryption using
        [[RFC9335]].
      </p>
      <pre class="idl">partial dictionary RTCConfiguration {
  RTCRtpHeaderEncryptionPolicy rtpHeaderEncryptionPolicy = "negotiate";
};</pre>
      <section>
        <h2>
          Dictionary {{RTCConfiguration}} Members
        </h2>
        <dl data-link-for="RTCConfiguration" data-dfn-for=
        "RTCConfiguration" class="dictionary-members">
          <dt>
            <dfn data-idl="">rtpHeaderEncryptionPolicy</dfn> of type <span class=
            "idlMemberType">RTCRtpHeaderEncryptionPolicy</span>
          </dt>
          <dd>
            <p class="needs-test">
            </p>
            <div class="issue atrisk">
              <p>
                {{RTCConfiguration/rtpHeaderEncryptionPolicy}} is marked
                as a feature at risk, since there is no clear commitment
                from implementers.
              </p>
            </div>
          </dd>
        </dl>
      </section>
    </section>
  </section>
  <section id="disable-hardware">
    <h2>Disabling hardware acceleration</h2>
    <p>
      While hardware acceleration of video encoding and decoding is generally desirable, it has proven to be
      operationally challenging to achieve in the environment of a browser with no detailed information about
      the underlying hardware. In some cases, falling back to software encoding yields better results.
    <p>
    <p class="note">
      The methods specified in this section should be used sparingly and not for extended amounts of time.
    </p>
    <p class="note">
      In privacy-sensitive contexts, browsers may disable hardware acceleration by default to
      reduce the fingerprinting surface.
    </p>
    <section id="disable-hardware-decoding">
      <h3>
        {{RTCRtpReceiver}} extensions
      </h3>
      <p>
        The {{RTCRtpReceiver}} interface is defined in [[WEBRTC]]. This document extends this interface
        by adding a static method and internal slot
        <dfn data-dfn-for=RTCRtpReceiver>{{RTCRtpReceiver/[[HardwareDisabled]]}}</dfn> initialized to <code>false</code>.
      </p>
      <pre class="idl">partial interface RTCRtpReceiver {
  static undefined disableHardwareDecoding();
};</pre>
      <p>When the {{RTCRtpReceiver}}'s disableHardwareDecoding method is called, the user agent MUST run the following steps:</p>
      <ol>
        <li>
          <p>When the <code>RTCPeerConnection.constructor()</code> has been invoked abort these steps.</p>
        </li>
        <li>
          <p>Set the RTCRtpReceiver's {{RTCRtpReceiver/[[HardwareDisabled]]}} slot to <code>true</code>.</p>
        </li>
      </ol>
    </section>
    <section id="disable-hardware-encoding">
      <h3>
        {{RTCRtpSender}} extensions
      </h3>
      <p>
        The {{RTCRtpSender}} interface is defined in [[WEBRTC]]. This document extends this interface
        by adding a static method and internal slot
        <dfn data-dfn-for=RTCRtpSender>{{RTCRtpSender/[[HardwareDisabled]]}}</dfn> initialized to <code>false</code>.
      </p>
      <pre class="idl">partial interface RTCRtpSender {
  static undefined disableHardwareEncoding();
};</pre>
      <p>When the {{RTCRtpSender}}'s disableHardwareEncoding method is called, the user agent MUST run the following steps:</p>
      <ol>
        <li>
          <p>When the <code>RTCPeerConnection.constructor()</code> has been invoked abort these steps.</p>
        </li>
        <li>
          <p>Set the RTCRtpSender's {{RTCRtpSender/[[HardwareDisabled]]}} slot to <code>true</code>.</p>
        </li>
      </ol>
    </section>
    <section id="disable-hardware-modifications">
      <h3>Modifications to existing procedures</h3>
      <p>
        In the <a data-cite="WEBRTC#set-description">set a session description</a> algorithm, add a step
        right after the step that sets transceiver.[[\Receiver]].[[\ReceiveCodecs]],
        saying "If the RTCRtpReceiver's {{RTCRtpReceiver/[[HardwareDisabled]]}} slot is <code>true</code>,
        remove any codec from transceiver.[[\Receiver]].[[\ReceiveCodecs]] for which the underlying decoder
        is hardware-accelerated".
      </p>
      <p>
        In the <a data-cite="WEBRTC#set-description">set a session description</a> algorithm, add a step
        right after the step that sets transceiver.[[\Sender]].[[\SendCodecs]],
        saying "If the RTCRtpSender's {{RTCRtpSender/[[HardwareDisabled]]}} slot is <code>true</code>,
        remove any codec from transceiver.[[\Sender]].[[\SendCodecs]] for which the underlying encoder
        is hardware-accelerated".
      </p>
    </section>
  </section>
  <section class="informative">
    <h2>Event summary</h2>
    <p>
      The following events fire on {{RTCIceTransport}} objects:</p>
    <table class="simple">
      <thead>
        <tr>
          <th>Event name</th>
          <th>Interface</th>
          <th>Fired when...</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <th scope=row><dfn data-dfn-for="RTCIceTransport" data-dfn-type=event>icecandidatepairadd</dfn></th>
          <td>{{RTCIceCandidatePairEvent}}</td>
          <td>
            The [= ICE agent =] has formed a candidate pair and is making it available to the script.
          </td>
        </tr>
        <tr>
          <th scope=row><dfn data-dfn-for="RTCIceTransport" data-dfn-type=event>icecandidatepairremove</dfn></th>
          <td>{{RTCIceCandidatePairEvent}}</td>
          <td>
            The [= ICE agent =] has picked a candidate pair to remove, and unless the operation is canceled by invoking the <code>preventDefault()</code> method on the event, it will be removed.
          </td>
        </tr>
        <tr>
          <th scope=row><dfn data-dfn-for="RTCIceTransport" data-dfn-type=event>icecandidatepairnominate</dfn></th>
          <td>{{RTCIceCandidatePairEvent}}</td>
          <td>
            The [= ICE agent =] has picked a valid candidate pair to {{nominate}}, and unless the operation is canceled by
            invoking the <code>preventDefault()</code> method on the event, it will be {{nominated}}.
          </td>
        </tr>
      </tbody>
    </table>
  </section>
  <section class="informative" id="security-considerations">
    <h2>
      Security Considerations
    </h2>
      <p>
        This section is non-normative; it specifies no new behaviour.
        The overall security considerations of the general set
        of APIs and protocols used in WebRTC are described in
        [[?RFC8827]].
      </p>
      <section>
        <h2>
          Impact on local network
        </h2>
        <p>
          The extensions defined in this document do not provide
          additional impact on the local network beyond what is described in
          [[WEBRTC]] Section 13.3.
        </p>
      </section>
      <section>
        <h2>
          Confidentiality of Communications
        </h2>
        <p>
          This document defines extensions for encryption of RTP Header Extensions which
          improve the confidentiality of communications by encrypting header extension
          IDs, as well as CSRCs.
        </p>
      </section>
  </section>
  <section class="informative" id="privacy-considerations">
      <h2>
        Privacy Considerations
      </h2>
        <p>
          This section is non-normative; it specifies no new behaviour.
        </p>
        <section>
          <h2>
            Revealing IP addresses
          </h2>
          <p>
            The extensions defined in this document do not reveal additional
            information on IP addresses beyond that already described in
            [[WEBRTC]] Section 13.2.
          </p>
        </section>
        <section>
          <h2>
            Persistent information exposed by WebRTC
          </h2>
          <p>
            The extensions defined in this document do not provide additional
            persistent information beyond that which is discussed in [[WEBRTC]]
            Section 13.5.
          </p>
        </section>
  </section>
  <section class="informative" id="accessibility-considerations">
        <h2>
          Accessibility Considerations
        </h2>
        <p>
          The WebRTC 1.0 specification exposes an API to control protocols
          (defined within the IETF) necessary to establish real-time audio, video
          and data exchange. Real-Time Text, defined in [[RFC4103]], is supported
          via the data channel API as described in [[WEBRTC]] Section 14. The
          extensions defined in this document do not affect support for Real-Time
          Text.
        </p>
  </section>
  <section class="appendix" id="Acknowledgements">
    <h2>Acknowledgements</h2>
    <p>
      The editors wish to thank the Working Group chairs and Team Contact,
      Dominique Hazal-Massieux, for their support. Substantial text in this
      specification was provided by many people including
      Harald Alvestrand, Justin Uberti and Peter Thatcher.
    </p>
    <p>
      The {{RTCRtpSender}} and {{RTCRtpReceiver}} objects were initially
      described in the <a href="https://www.w3.org/community/ortc/">W3C ORTC
      CG</a>, and have been adapted for use in this specification.
    </p>
  </section>
</body>
</html>
