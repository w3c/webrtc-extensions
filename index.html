<!DOCTYPE html>
<html lang="en" dir="ltr">
<head>
  <meta charset="utf-8">
  <link href="webrtc.css" rel="stylesheet">
  <title>WebRTC Extensions</title>
  <script class="remove" src="https://www.w3.org/Tools/respec/respec-w3c"></script>
  <script class="remove" src="ext-respec-config.js" ></script>
</head>
<body>
  <section id="abstract">
    <p>
      This document defines a set of ECMAScript APIs in WebIDL to extend the WebRTC 1.0 API.
    </p>
  </section>
  <section id="sotd">
    <p>The API is based on preliminary work done in the W3C WEBRTC Working Group.</p>
  </section>
  <section class="informative" id="intro">
    <h2>Introduction</h2>
    <p>
      This document contains proposed extensions to the [[WEBRTC]] specification.
      Some of these extensions were originally included within the [[WEBRTC]] specification,
      but needed to be removed due to lack of implementation experience. Others were not
      sufficiently mature to be incorporated into that specification when they were developed,
      but were too small to warrant creation of a separate document.
    </p>
    <p>
      This document contains some sections extending one specific interface or dictionary in
      the base specification; in this case the extension is only described in an individual
      section. Where an extension affects multiple interfaces or dictionaries, a subsection
      in the "Overviews" section describes the extension as a whole, while normative text
      is provided in sections relating to the individual interfaces.
    </p>
    <p>
      As extensions mature and gain implementation experience, they may move from this document
      to the base specification if WG consensus emerges to do so.
    </p>
  </section>
  <section id="conformance">
    <p>This specification defines conformance criteria that apply to a single
    product: the <dfn>user agent</dfn> that implements the interfaces that it
    contains.</p>
    <p>Conformance requirements phrased as algorithms or specific steps may be
    implemented in any manner, so long as the end result is equivalent. (In
    particular, the algorithms defined in this specification are intended to be
    easy to follow, and not intended to be performant.)</p>
    <p>Implementations that use ECMAScript to implement the APIs defined in
    this specification MUST implement them in a manner consistent with the
    ECMAScript Bindings defined in the Web IDL specification [[WEBIDL]], as
    this specification uses that specification and terminology.</p>
  </section>
  <section>
    <h2>Terminology</h2>
    <p>
      The following terms are defined in
      <a href="https://webrtc.org/experiments/rtp-hdrext/abs-capture-time"><dfn>RTP Header Extension for Absolute Capture Time</dfn></a>:
      <ul>
        <li><a href="https://webrtc.org/experiments/rtp-hdrext/abs-capture-time#absolute-capture-timestamp"><dfn>absolute capture timestamp</dfn></a>
        <li><a href="https://webrtc.org/experiments/rtp-hdrext/abs-capture-time#timestamp-interpolation"><dfn>timestamp interpolation</dfn></a>
        <li><a href="https://webrtc.org/experiments/rtp-hdrext/abs-capture-time#estimated-capture-clock-offset"><dfn>estimated capture clock offset</dfn></a>
      </ul>
    </p>
    <p>The process of <dfn>chaining</dfn> an operation to an <dfn>operations chain</dfn> is defined in [[WEBRTC]] Section 4.4.1.2.</p>
    <p>The <dfn>OAuth Client</dfn> and <dfn>Authorization Server</dfn> roles
      are defined in [[RFC6749]] Section 1.1.</p>
  </section>
  <section id="overviews">
    <h2>Overviews</h2>
    <section id="rtp-header-control">
      <h3>RTP header control</h3>
      <p>
        RTP header extension control is an extension to {{RTCRtpTransceiver}} that allows
        to set and query the RTP header extensions supported and negotiated in SDP.
      <p>
        The RTP header extension mechanism is defined in [[RFC8285]], with
        the SDP negotiation mechanism defined in section 5. It goes into some
        detail on the meaning of "direction" with regard to RTP header
        extensions, and gives a detailed procedure for negotiating RTP header
        extension IDs.
      </p>
      <p>
        This API extension gives the means to control the use and direction of
        RTP header extensions as documented in [[RFC8285]]. It does not
        influence the ID negotiation mechanism, except for being able to
        control the number of extensions offered.
      </p>
    </section>
  </section>
  <section id="rtcpeerconnection-interface">
    <h3>
      {{RTCPeerConnection}} extensions
    </h3>
    <p>
      The {{RTCPeerConnection}} interface is defined in [[WEBRTC]]. This document
      extends that interface by using Content-Security-Policy for ICE candidate
      filtering.
    </p>
    <section>
      <h2>Modifications to existing procedures</h2>

      <p>Append the following paragraph to the
      <a data-cite="WEBRTC#dfn-administratively-prohibited">administratively prohibited</a>
      algorithm:</p>

      <p>If <a data-cite="CSP#should-block-rtc-connection">
        should RTC connections be blocked for global?</a> with the
      [=relevant global object=] of the {{RTCPeerConnection}} object in question
      returns `"Blocked"`, then all candidates MUST be <a
        data-cite="WEBRTC#dfn-administratively-prohibited">
        administratively prohibited</a>.</p>
    </section>
  </section>
  <section id="rtcrtptransceiver-interface">
    <h3>
      {{RTCRtpTransceiver}} extensions
    </h3>
    <p>
      The {{RTCRtpTransceiver}}
      interface is defined in [[WEBRTC]]. This document extends that interface
      by adding an additional method and attribute in order to control negotiation of
      RTP header extensions.
    </p>
    <pre class="idl">
partial dictionary RTCRtpHeaderExtensionCapability {
  RTCRtpTransceiverDirection direction = "sendrecv";
};

partial interface RTCRtpTransceiver {
  sequence&lt;RTCRtpHeaderExtensionCapability&gt; getHeaderExtensionsToNegotiate();
  undefined setHeaderExtensionsToNegotiate(
      sequence&lt;RTCRtpHeaderExtensionCapability&gt; extensions);
  sequence&lt;RTCRtpHeaderExtensionCapability&gt; getNegotiatedHeaderExtensions();
};
    </pre>
    <p>
      Let
      <dfn data-dfn-for=RTCRtpTransceiver>{{RTCRtpTransceiver/[[HeaderExtensionsToNegotiate]]}}</dfn>
      and
      <dfn data-dfn-for=RTCRtpTransceiver>{{RTCRtpTransceiver/[[NegotiatedHeaderExtensions]]}}</dfn>
      be internal slots of the {{RTCRtpTransceiver}}, initialized as follows:
    </p>
    <ol>
      <li>
        <p>Set {{RTCRtpTransceiver/[[HeaderExtensionsToNegotiate]]}} to the
        platform-specific list of implemented RTP header extensions. The
        {{RTCRtpHeaderExtensionCapability/direction}} attribute for all
        extensions that are mandatory to use MUST be initialized to an
        appropriate value other than {{RTCRtpTransceiverDirection/"stopped"}}.
        The {{RTCRtpHeaderExtensionCapability/direction}} attribute for
        extensions that will not be offered by default in an initial offer MUST
        be initialized to {{RTCRtpTransceiverDirection/"stopped"}}.</p>
        <p class="note">The list of header extensions that MUST/SHOULD be
        supported is listed in [[RTCWEB-RTP]], section 5.2. The "mid" extension
        is mandatory to use when BUNDLE is in use, per [[BUNDLE]] section
        9.1.</p>
      </li>
      <li>
        <p>Set {{RTCRtpTransceiver/[[HeaderExtensionsToNegotiate]]}} to an empty
        list.</p>
      </li>
    </ol>
    <section>
      <h2>Modifications to existing procedures</h2>
      <p>
        Make the following modifications to the
        <a data-cite="WEBRTC#set-description">set a session description</a>
        algorithm:
      </p>
      <ul>
        <li>
          <p>In the steps for processing each <var>media description</var> of a
          remote <var>description</var> (<var>remote</var> is
          <code>true</code>), after <var>transceiver</var> has been found or
          created, insert the following steps:</p>
          <ol>
            <li>
              <p>If <var>description</var> is of type {{RTCSdpType/"offer"}},
              then for each <var>extension</var> in
              <var>transceiver.</var>{{RTCRtpTransceiver/[[HeaderExtensionsToNegotiate]]}},
              run the following steps:</p>
              <ol>
                <li>
                  <p>Let <var>offeredDirection</var> be the direction attribute
                  of the "a=extmap" line in the remote offer's
                  <var>media description</var> that correspond to this
                  <var>extension</var> if one exists, otherwise set
                  <var>offeredDirection</var> to
                  {{RTCRtpTransceiverDirection/"stopped"}}.</p>
                </li>
                <li>
                  <p>Reverse <var>offeredDirection</var> to represent the peer's
                  point if view.</p>
                </li>
                <li>
                  <p>If necessary, restrict <var>offeredDirection</var> as to
                  not exceed the user agent's capabilities for this
                  extension.</p>
                </li>
                <li>
                  <p>Set
                  <var>extension</var>.{{RTCRtpHeaderExtensionCapability/direction}}
                  to <var>offeredDirection</var>.</p>
                </li>
              </ol>
            </li>
          </ol>
        </li>
        <li>
          <p>In the later steps for processing a <var>description</var> of type
          {{RTCSdpType/"answer"}} that runs for both local and remote
          descriptions, insert the following steps:</p>
          <ol>
            <li>
              <p>For each <var>media description</var> and corresponding
              <var>transceiver</var>, let <var>negotiatedExtensions</var> be the
              value of
              <var>transceiver</var>.{{RTCRtpTransceiver/[[HeaderExtensionsToNegotiate]]}}.</p>
            </li>
            <li>
              <p>For each <var>extension</var> in
              <var>negotiatedExtensions</var>, run the following steps:</p>
              <ol>
                <li>
                  <p>Let <var>answeredDirection</var> be the direction attribute
                  of the "a=extmap" line in the answer's
                  <var>media description</var> that correspond to this
                  <var>extension</var> if one exists, otherwise set
                  <var>answeredDirection</var> to
                  {{RTCRtpTransceiverDirection/"stopped"}}.</p>
                </li>
                <li>
                  <p>If <var>description</var> is a remote description, reverse
                  <var>answeredDirection</var> to represent the peer's point of
                  view.</p>
                </li>
                <li>
                  <p>Set
                  <var>extension</var>.{{RTCRtpHeaderExtensionCapability/direction}}
                  to <var>answeredDirection</var>.</p>
                </li>
              </ol>
            </li>
            <li>
              <p>Set
              <var>transceiver</var>.{{RTCRtpTransceiver/[[NegotiatedHeaderExtensions]]}}
              to <var>negotiatedExtensions</var>.</p>
            </li>
          </ol>
        </li>
      </ul>
      <p>
        In the algorithms for generating initial offers in [[RTCWEB-JSEP]] section 5.2.1,
        replace "for each supported RTP header extension, an "a=extmap" line, as specified in
        [[RFC5285]], section 5" " with "For each RTP header extension "e"
        listed in {{RTCRtpTransceiver/[[HeaderExtensionsToNegotiate]]}} where {{RTCRtpHeaderExtensionCapability/direction}} is not {{RTCRtpTransceiverDirection/"stopped"}}, an "a=extmap"
        line, as specified in [[RFC5285]], section 5, with direction taken from "e"'s {{RTCRtpHeaderExtensionCapability/direction}}
        attribute."
      </p>
      <p>
        In the algorithm for generating subsequent offers in [[RTCWEB-JSEP]] section 5.2.2, replace "The
        RTP header extensions MUST only include those that are present in the most recent answer"
        with "For each RTP header extension listed in {{RTCRtpTransceiver/[[HeaderExtensionsToNegotiate]]}},
        and where {{RTCRtpHeaderExtensionCapability/direction}} is not {{RTCRtpTransceiverDirection/"stopped"}}, generate
        an appropriate "a=extmap" line with "direction" set according to the rules of [[RFC5285]]
        section 6, considering the {{RTCRtpHeaderExtensionCapability/direction}} in {{RTCRtpTransceiver/[[HeaderExtensionsToNegotiate]]}} to indicate the
        answerer's desired usage".
      </p>
      <p>
        In the algorithm for generating initial answers in [[RTCWEB-JSEP]] section 5.3.1, replace "For
        each supported RTP header extension that is present in the offer" with "For each
        supported RTP header extension that is present in the offer and is also present in
        {{RTCRtpTransceiver/[[HeaderExtensionsToNegotiate]]}} with a {{RTCRtpHeaderExtensionCapability/direction}} different from {{RTCRtpTransceiverDirection/"stopped"}},
        set the appropriate direction based on {{RTCRtpHeaderExtensionCapability/direction}} that does not exceed the direction in the offer".
      </p>
      <p class="note">
        Since JSEP does not know about WebRTC internal slots, merging this change requires
        more work on a JSEP revision.
      </p>
    </section>
    <section>
      <h2>Methods</h2>
      <dl>
        <dt><dfn data-dfn-for=RTCRtpTransceiver>getHeaderExtensionsToNegotiate</dfn></dt>
        <dd>
          <p>Execute the following steps:</p>
          <ol>
            <li>
              <p>Let <var>transceiver</var> be the {{RTCRtpTransceiver}} that
              this method was invoked on.</p>
            </li>
            <li>
              <p>Return
              <var>transceiver</var>.{{RTCRtpTransceiver/[[HeaderExtensionsToNegotiate]]}}.</p>
            </li>
          </ol>
        </dd>
      </dl>
      <dl>
        <dt><dfn data-dfn-for=RTCRtpTransceiver>setHeaderExtensionsToNegotiate</dfn></dt>
        <dd>
          <p>Execute the following steps:</p>
          <ol>
            <li>
              <p>Let <var>transceiver</var> be the {{RTCRtpTransceiver}} that
              this method was invoked on.</p>
            </li>
            <li>
              <p>Let <var>extensions</var> be the first argument of this
              method.</p>
            </li>
            <li>
              <p>If the size of <var>extensions</var> does not match the size of
              <var>transceiver</var>.{{RTCRtpTransceiver/[[HeaderExtensionsToNegotiate]]}}
              [=exception/throw=] an {{InvalidModificationError}}.
              </p>
            </li>
            <li>
              <p>For each index <var>i</var> of <var>extensions</var>, run the
              following steps:</p>
              <ol>
                <li>
                  <p>Let <var>extension</var> be the <var>i</var>-th element of
                  <var>extensions</var>.</p>
                </li>
                <li>
                  <p>If
                  <var>extension</var>.{{RTCRtpHeaderExtensionCapability/uri}}
                  or
                  <var>extension</var>.{{RTCRtpHeaderExtensionCapability/direction}}
                  is missing, [=exception/throw=] a {{TypeError}}.</p>
                </li>
                <li>
                  <p>If
                  <var>extension</var>.{{RTCRtpHeaderExtensionCapability/uri}}
                  is not equal to the {{RTCRtpHeaderExtensionCapability/uri}} of
                  the <var>i</var>-th element of
                  <var>transceiver</var>.{{RTCRtpTransceiver/[[HeaderExtensionsToNegotiate]]}},
                  [=exception/throw=] an {{InvalidModificationError}}.</p>
                </li>
                <li>
                  <p>If
                  <var>extension</var>.{{RTCRtpHeaderExtensionCapability/direction}}
                  is not {{RTCRtpTransceiverDirection/"sendrecv"}} and
                  {{RTCRtpHeaderExtensionParameters/uri}} indicates a
                  mandatory-to-use attribute that is required to be both sent
                  and received, [=exception/throw=] an
                  {{InvalidModificationError}}.</p>
                </li>
                <li>
                  <p>If
                  <var>extension</var>.{{RTCRtpHeaderExtensionCapability/direction}}
                  is {{RTCRtpTransceiverDirection/"stopped"}} and
                  {{RTCRtpHeaderExtensionCapability/uri}} indicates a
                  mandatory-to-implement extension, [=exception/throw=] an
                  {{InvalidModificationError}}.</p>
                </li>
                <li>
                  <p>If necessary, restrict
                  <var>extension</var>.{{RTCRtpHeaderExtensionCapability/direction}}
                  as to not exceed the user agent's capabilities for this
                  extension.</p>
                </li>
              </ol>
            </li>
            <li>
              <p>Set
              <var>transceiver</var>.{{RTCRtpTransceiver/[[HeaderExtensionsToNegotiate]]}}
              to <var>extensions</var>.</p>
            </li>
          </ol>
        </dd>
      </dl>
      <dl>
        <dt><dfn data-dfn-for=RTCRtpTransceiver>getNegotiatedHeaderExtensions</dfn></dt>
        <dd>
          <p>Execute the following steps:</p>
          <ol>
            <li>
              <p>Let <var>transceiver</var> be the {{RTCRtpTransceiver}} that
              this method was invoked on.</p>
            </li>
            <li>
              <p>Return
              <var>transceiver</var>.{{RTCRtpTransceiver/[[NegotiatedHeaderExtensions]]}}.</p>
            </li>
          </ol>
        </dd>
      </dl>
    </section>
  </section>
  <section id="rtcrtpreceiver-interface">
    <h3>
      {{RTCRtpReceiver}} extensions
    </h3>
    <p>
      The {{RTCRtpReceiver}}
      interface is defined in [[WEBRTC]]. This document extends that interface
      by adding an additional internal slot and attribute.
    </p>
    <p>
      Let {{RTCRtpReceiver}} objects have a <dfn data-dfn-for=RTCRtpReceiver>[[\PlayoutDelay]]</dfn> internal slot initially
      initialized to <code>null</code>.
    </p>
    <pre class="idl">partial interface RTCRtpReceiver {
  attribute double? playoutDelay;
  };</pre>
    <section>
      <h2>Attributes</h2>
      <dl data-link-for="RTCRtpReceiver" data-dfn-for="RTCRtpReceiver"
      class="attributes">
        <dt><dfn>playoutDelay</dfn> of type <span
          class="idlAttrType">double</span>, nullable</dt>
        <dd>
          <p>This attribute allows the application to specify a target duration
          of time between network reception of media and playout. The
          <a>user agent</a> SHOULD NOT playout audio or video that is received unless
          this amount of time has passed in seconds, allowing the <a>user agent</a>
          to perform more or less buffering than it might otherwise do.
          This allows to influence the tradeoffs between having a higher delay
          and the risk that buffers such as the jitter buffer will run out of
          audio or video frames to play due to network jitter.</p>
          <p>The <a>user agent</a> may have a <dfn>minimum allowed delay</dfn> and a
          <dfn>maximum allowed delay</dfn> reflecting what the <a>user agent</a> is
          able or willing to provide based on network conditions and memory
          constraints.</p>
          <p class="note">
            The playout delay hint applies even if DTX is used. For example, if
            DTX is used and packets start flowing after silence, the hint can
            influence the <a>user agent</a> to buffer these packets rather than playing
            them out.
          </p>
          <p class="note">
            If the track is paired with other tracks through
            {{RTCRtpReceiver}}
            <a data-cite="WEBRTC#dfn-associatedremotemediastreams">
            [[\AssociatedRemoteMediaStreams]]</a> internal slot, then it will
            be synchronized with other tracks (for e.g. audio video
            synchronization). This means that even if one of the paired tracks
            is delayed through {{RTCRtpReceiver/[[PlayoutDelay]]}} then the <a>user agent</a>
            synchronization mechanism will automatically delay all others
            paired tracks. If multiple such paired tracks are delayed through
            {{RTCRtpReceiver/[[PlayoutDelay]]}} by different amounts then the largest
            of those hints will take precedence in synchronization mechanism.
          </p>
          <p class="note">
            The receiver's average delay can be measured as the delta
            {{RTCInboundRtpStreamStats/jitterBufferDelay}} divided by the delta
            {{RTCInboundRtpStreamStats/jitterBufferEmittedCount}}.
          </p>
          <p>On getting, this attribute MUST return the value of the
          {{RTCRtpReceiver/[[PlayoutDelay]]}} internal slot.</p>
          <p>On setting, the <a>user agent</a> MUST run the following steps:</p>
          <ol>
            <li>
              <p>Let <var>receiver</var> be the
              {{RTCRtpReceiver}} object on which the setter is
              invoked.</p>
            </li>
            <li>
              <p>Let <var>delay</var> be the argument to the setter.</p>
            </li>
            <li>
              <p>If <var>delay</var> is negative or larger than 4 seconds then,
              [=exception/throw=] a {{RangeError}} and abort these steps.</p>
            </li>
            <li>
              <p>Set the value of <var>receiver</var>'s {{RTCRtpReceiver/[[PlayoutDelay]]}}
              internal slot to <var>delay</var>.</p>
            </li>
            <li>
              <p>In parallel, begin executing the following steps:</p>
              <ol>
                <li>
                  <p>Update the underlying system about the new delay request,
                  or that there is no hint if <var>delay</var> is
                  <code>null</code>.</p>
                  <p>If the given delay value is below <a>minimum allowed
                  delay</a> or above <a>maximum allowed delay</a> then the
                  value used MUST be clamped to <a>minimum allowed
                  delay</a> or <a>maximum allowed delay</a> to be as close as
                  possible to the requested one.</p>
                  <p class="note">
                    If the <a>user agent</a> chooses a delay different from the requested
                    one (e.g. due to network conditions or physical memory
                    constraints), this is not reflected in the
                    {{RTCRtpReceiver/[[PlayoutDelay]]}} internal slot.
                  </p>
                </li>
                <li>
                  <p>Modifying the delay of the underlying system SHOULD affect
                  the internal audio or video buffering gradually in order not
                  to hurt user experience. Audio samples or video frames SHOULD
                  be accelerated or decelerated before playout, similarly to how
                  it is done for
                  <a data-cite="RFC5888#section-7">
                  audio/video synchronization</a> or in response to congestion
                  control.</p>
                  <p>The acceleration or deceleration rate may vary depending on
                  network conditions or the type of audio received (e.g. speech
                  or background noise). It MAY take several seconds to achieve 1
                  second of buffering but SHOULD not take more than 30 seconds
                  assuming packets are being received. The speed MAY be
                  different for audio and video.</p>
                  <p class="note">
                    For audio, acceleration and deceleration can be measured
                    with {{RTCInboundRtpStreamStats/insertedSamplesForDeceleration}}
                    and {{RTCInboundRtpStreamStats/removedSamplesForAcceleration}}.
                    For video, this may result in the same frame being rendered
                    multiple times or frames may be dropped.
                  </p>
                </li>
              </ol>
            </li>
          </ol>
        </dd>
      </dl>
    </section>
  </section>
  <section id="rtcrtpencodingparameters-dictionary">
    <h3>
      RTCRtpEncodingParameters extensions
    </h3>
    <p>
      The {{RTCRtpEncodingParameters}} dictionary is defined in
      [[WEBRTC]]. This document extends that dictionary with
      additional members.
    </p>
    <pre class="idl">partial dictionary RTCRtpEncodingParameters {
      unsigned long ptime;
      boolean adaptivePtime = false;
    };</pre>
    <h2>Dictionary {{RTCRtpEncodingParameters}} Members</h2>
    <dl data-link-for="RTCRtpEncodingParameters" data-dfn-for="RTCRtpEncodingParameters" class="dictionary-members">
      <dt><dfn data-idl>ptime</dfn> of type <span class="idlMemberType">unsigned long</span></dt>
      <dd>
        <p>The preferred duration of media represented by a packet in milliseconds.</p>
          <div class="issue atrisk">
            <p>
              {{RTCRtpEncodingParameters/ptime}} was moved from [[WEBRTC]] to
              this specification due to lack of support from implementers. It is
              therefore marked as a feature at risk.
            </p>
          </div>
      </dd>
      <dt><dfn data-idl>adaptivePtime</dfn> of type <span class="idlMemberType">boolean</span>, defaulting to <code>false</code>.</dt>
      <dd>
        <p>Indicates whether this encoding MAY dynamically change
        the frame length. If the value is <code>true</code>, the
        <a>user agent</a> MAY use any valid frame length for any of its
        frames, and MAY change this at any time. Valid values are
        multiples of 10ms. If the <code>maxptime</code> attribute
        (defined in [[RFC4566]] Section 6) is specified, that maximum
        applies. If the value is <code>false</code>, the <a>user agent</a>
        MUST use a fixed frame length.</p>
        <p>If {{adaptivePtime}} is set to <code>true</code>,
        {{ptime}} MUST NOT be set; otherwise,
        {{InvalidModificationError}} MUST be [=exception/throw|thrown=].</p>
        <p class="note">Using a longer frame length reduces the
        bandwidth consumption due to overhead, but does so at the cost
        of increased latency. Changing the frame length dynamically
        allows the <a>user agent</a> to adapt its bandwidth allocation strategy
        based on the current network conditions.</p>
      </dd>
    </dl>
  </section>
  <section id="rtcrtpcontributingsource-dictionary">
    <h3>
      {{RTCRtpContributingSource}} extensions
    </h3>
    <p>
      The {{RTCRtpContributingSource}} dictionary is defined in [[WEBRTC]]. This
      document extends that dictionary by adding two additional members.
    </p>
    <p>
      In this section, the <dfn>capture system</dfn> refers to the system where
      media is sourced from and the <dfn>sender system</dfn> refers to the
      system that is sending RTP and RTCP packets to the
      <dfn>receiver system</dfn> where {{RTCRtpContributingSource}} data is
      populated.
    </p>
    <p>
      In a direct connection, the <a>capture system</a> is the same as the
      <a>sender system</a>. But when one or more RTCP-terminating intermediate
      systems (e.g. mixers) are involved this is not the case. In such cases,
      media is sourced from the <a>capture system</a>, may be relayed through a
      number of intermediate systems and is then finally sent from the
      <a>sender system</a> to the <a>receiver system</a>. The
      <a>sender system</a>-<a>receiver system</a> path only represents the
      "last hop".
    </p>
    <p>
      Despite {{RTCRemoteInboundRtpStreamStats.roundTripTime}}
      measurements only accounting for the "last hop", one-way delay from the
      [=capture system=]'s time of capture to the [=receiver system=]'s
      time of playout can be estimated if the
      [=RTP Header Extension for Absolute Capture Time=] is used all hops of
      the way, where each RTCP-terminating intermediate system appropriately
      updates the [=estimated capture clock offset=].
    </p>
    <pre class="idl">partial dictionary RTCRtpContributingSource {
      DOMHighResTimeStamp captureTimestamp;
      DOMHighResTimeStamp senderCaptureTimeOffset;
    };</pre>
    <h2>Dictionary {{RTCRtpContributingSource}} Members</h2>
    <dl data-link-for="RTCRtpContributingSource" data-dfn-for="RTCRtpContributingSource" class="dictionary-members">
      <dt><dfn data-idl>captureTimestamp</dfn> of type {{DOMHighResTimeStamp}}.</dt>
      <dd>
        <p>
          The {{captureTimestamp}} is the timestamp that, the most recent frame
          (from an RTP packet originating from this source) delivered to the
          {{RTCRtpReceiver}}'s {{MediaStreamTrack}}, was originally captured.
          Its reference clock is the <a>capture system</a>'s NTP clock (same
          clock used to generate NTP timestamps for RTCP sender reports on that
          system).
        </p>
        <p>
          On populating this member, the <a>user agent</a> MUST run the following
          steps:
        </p>
        <ol>
          <li>
            <p>If the relevant RTP packet contains the
            <a>RTP Header Extension for Absolute Capture Time</a>, return the
            value of the <a>absolute capture timestamp</a> field and abort
            these steps.</p>
          </li>
          <li>
            <p>Otherwise, if the relevant RTP packet does not contain the
            <a>RTP Header Extension for Absolute Capture Time</a> but a
            previous RTP packet did, return the result of calculating the
            absolute capture timestamp according to
            <a>timestamp interpolation</a> and abort these steps.</p>
          </li>
          <li>
            Otherwise, return <code>undefined</code>.
          </li>
        </ol>
        <p class="note">
          If multiple receiving tracks are sourced from the same
          <a>capture system</a>, two {{captureTimestamp}}s can be used to
          accurately measure audio-video synchronization since both timestamps
          are based on the same system's clock.
        </p>
      </dd>
      <dt><dfn data-idl>senderCaptureTimeOffset</dfn> of type {{DOMHighResTimeStamp}}.</dt>
      <dd>
        <p>
          The {{senderCaptureTimeOffset}} is the <a>sender system</a>'s
          estimate of the offset between its own NTP clock and the
          <a>capture system</a>'s NTP clock, for the same frame that the
          {{captureTimestamp}} was originated from.
        </p>
        <p>
          On populating this member, the <a>user agent</a> MUST run the following
          steps:
        </p>
        <ol>
          <li>
            <p>If the relevant RTP packet contains the
            <a>RTP Header Extension for Absolute Capture Time</a> and the
            <a>estimated capture clock offset</a> field is present, return the
            value of the <a>estimated capture clock offset</a> field and abort
            these steps.</p>
          </li>
          <li>
            <p>Otherwise, if the relevant RTP packet does not contain the
            <a>RTP Header Extension for Absolute Capture Time</a>'s
            <a>estimated capture clock offset</a> field, but a
            previous RTP packet did, return the most recent value that was
            present and abort these steps.</p>
          </li>
          <li>
            Otherwise, return <code>undefined</code>.
          </li>
        </ol>
        <p class="note">
          The time of capture can estimatedly be expressed in the
          <a>sender system</a>'s clock as follows:
          <var>senderCaptureTimestamp</var> = {{captureTimestamp}} +
          {{senderCaptureTimeOffset}}.
        </p>
        <p class="note">
          The offset between the <a>sender system</a>'s clock and the
          <a>receiver system</a>'s clock can be estimated as follows:
          <var>senderReceiverTimeOffset</var> =
          {{RTCRemoteOutboundRtpStreamStats}}.<a class=fixme data-cite="WEBRTC#dom-rtcstats-timestamp">timestamp</a>}} -
          ({{RTCRemoteOutboundRtpStreamStats.remoteTimestamp}} +
          {{RTCRemoteInboundRtpStreamStats.roundTripTime}} / 2).
        </p>
        <p class="note">
          The time of capture can estimatedly be expressed in the
          <a>receiver system</a>'s clock as follows:
          <var>receiverCaptureTimestamp</var> = <var>senderCaptureTimestamp</var> +
          <var>senderReceiverTimeOffset</var>.
        </p>
        <p class="note">
          The one-way delay between the <a>capture system</a>'s time of capture
          and the <a>receiver system</a>'s time of playout can be estimated as
          follows:
          {{RTCRtpContributingSource.timestamp}} -
          <var>receiverCaptureTimestamp</var>.
        </p>
        </p>
      </dd>
    </dl>
</section>
<section>
   <h3>
     {{RTCDataChannel}} extensions
   </h3>
   <section>
      <h3>Transferable Data Channels</h3>
      <p>This document extends {{RTCDataChannel}} by making it <a data-cite="!HTML/#transferable-objects">transferable</a>.</p>
      This allows sending and receiving messages outside the context the connection was created, for instance in workers or third-party iframes.</p>
    <div>
      <p>The WebIDL changes are the following:
      <pre class="idl">
[Exposed=(Window,Worker), Transferable]
partial interface RTCDataChannel {
};</pre>
    </div>
    <div>
      <p>The <a data-cite="WEBRTC#dfn-create-an-rtcdatachannel">create an RTCDataChannel</a> algorithm is updated by adding the following steps after step 4 of the original algorithm:</p>
      <ol>
        <li><p>Initialize <var>channel</var>.`[[IsTransferable]]` to <code>true</code>.</p></li>
        <li><p>Queue a task to run the following step:</p>
          <ol>
            <li><p>Set <var>channel</var>.`[[IsTransferable]]` to <code>false</code>.</p></li>
          </ol>
        </li>
      </ol>
      <p>This task needs to run before any task enqueued by the <a data-cite="WEBRTC#dfn-receive-an-rtcdatachannel-message">receiving messages on a data channel</a> algorithm for <var>channel</var>.
      This ensures that no message is lost during the transfer of a {{RTCDataChannel}}.</p>
    </div>
    <div>The <a data-cite="WEBRTC#datachannel-send">send() algorithm</a> is modified by adding the following step after step 1 of the original algorithm:
      <ol>
        <li><p>Set <var>channel</var>.`[[IsTransferable]]` to <code>false</code>.</p></li>
      </ol>
    </div>
    <div>
      <p>The {{RTCDataChannel}} <a data-cite="!HTML/#transfer-steps">transfer steps</a>, given <var>value</var> and <var>dataHolder</var>, are:</p>
      <ol>
        <li><p>If <var>value</var>.`[[IsTransferable]]` is <code>false</code>, throw a "DataCloneError" DOMException.</p></li>
        <li><p>Set <var>dataHolder</var>.`[[ReadyState]]` to <var>value</var>.<a href="WEBRTC#dfn-readystate">`[[ReadyState]]`</a>.</p></li>
        <li><p>Set <var>dataHolder</var>.`[[DataChannelLabel]]` to <var>value</var>.<a href="WEBRTC#dfn-datachannellabel">`[[DataChannelLabel]]`</a>.</p></li>
        <li><p>Set <var>dataHolder</var>.`[[Ordered]]` to <var>value</var>.<a href="WEBRTC#dfn-ordered">`[[Ordered]]`</a>.</p></li>
        <li><p>Set <var>dataHolder</var>.`[[MaxPacketLifeTime]]` to <var>value</var>.<a href="WEBRTC#dfn-maxpacketlifetime"></a>.`[[MaxPacketLifeTime]]`</p></li>
        <li><p>Set <var>dataHolder</var>.`[[MaxRetransmits]]` to <var>value</var>.<a href="WEBRTC#dfn-maxretransmits">`[[MaxRetransmits]]`</a>.</p></li>
        <li><p>Set <var>dataHolder</var>.`[[DataChannelProtocol]]` to <var>value</var>.<a href="WEBRTC#dfn-datachannelprotocol">`[[DataChannelProtocol]]`</a>.</p></li>
        <li><p>Set <var>dataHolder</var>.`[[Negotiated]]` to <var>value</var>.<a href="WEBRTC#dfn-negotiated">`[[Negotiated]]`</a>.</p></li>
        <li><p>Set <var>dataHolder</var>.`[[DataChannelId]]` to <var>value</var>.<a href="WEBRTC#dfn-datachannelid">`[[DataChannelId]]`</a>.</p></li>
        <li><p>Set <var>dataHolder</var>.`[[underlyingDataTransport]]` to <var>value</var> <a href="WEBRTC#dfn-data-transport">underlying data transport</a>.</p></li>
        <li><p>Set <var>value</var>.`[[IsTransferable]]` to <code>false</code>.</p></li>
        <li><p>Set <var>value</var>.`[[ReadyState]]` to <a data-cite="WEBRTC/#dom-rtcdatachannelstate-closed">"closed"</a>.</p></li>
      </ol>
    </div>
    <div><p>The {{RTCDataChannel}} <a data-cite="!HTML/#transfer-receiving-steps">transfer-receiving steps</a>, given <var>dataHolder</var> and <var>channel</var>, are:</p>
      <ol>
        <li><p>Initialize <var>channel</var>.<a href="WEBRTC#dfn-readystate">`[[ReadyState]]`</a> to <var>dataHolder</var>.`[[ReadyState]]`.</p></li>
        <li><p>Initialize <var>channel</var>.<a href="WEBRTC#dfn-datachannellabel">`[[DataChannelLabel]]`</a> to <var>dataHolder</var>.`[[\DataChannelLabel]]`.</p></li>
        <li><p>Initialize <var>channel</var>.<a href="WEBRTC#dfn-ordered">`[[Ordered]]`</a> to <var>dataHolder</var>.`[[Ordered]]`.</p></li>
        <li><p>Initialize <var>channel</var>.<a href="WEBRTC#dfn-maxpacketlifetime">`[[MaxPacketLifeTime]]`</a> to <var>dataHolder</var>.`[[MaxPacketLifeTime]]`.</p></li>
        <li><p>Initialize <var>channel</var>.<a href="WEBRTC#dfn-maxretransmits">`[[MaxRetransmits]]`</a> to <var>dataHolder</var>.`[[MaxRetransmits]]`.</p></li>
        <li><p>Initialize <var>channel</var>.<a href="WEBRTC#dfn-datachannelprotocol">`[[DataChannelProtocol]]`</a> to <var>dataHolder</var>.`[[DataChannelProtocol]]`.</p></li>
        <li><p>Initialize <var>channel</var>.<a href="WEBRTC#dfn-negotiated">`[[Negotiated]]`</a> to <var>dataHolder</var>.`[[Negotiated]]`.</p></li>
        <li><p>Initialize <var>channel</var>.<a href="WEBRTC#dfn-datachannelid">`[[DataChannelId]]`</a> to <var>dataHolder</var>.`[[DataChannelId]]`.</p></li>
        <li><p>Initialize <var>channel</var> <a href="WEBRTC#dfn-data-transport">underlying data transport</a> to <var>dataHolder</var>.`[[underlyingDataTransport]]`.</p></li>
      </ol>
      <p>The above steps do not need to transfer <a href="WEBRTC#dfn-readystate">`[[BufferedAmount]]`</a> as its value will always be equal to <code>0</code>.
      The reason is an {{RTCDataChannel}} can be transferred only if its <a data-cite="WEBRTC#datachannel-send">send() algorithm</a> was not called prior the transfer.</p>
      <p>If the <a href="WEBRTC#dfn-data-transport">underlying data transport</a> is closed at the time of the <a data-cite="!HTML/#transfer-receiving-steps">transfer-receiving steps</a>,
      the {{RTCDataChannel}} object will be closed by running the <a href="WEBRTC#announcing-a-data-channel-as-closed">announcing a data channel as closed</a> algorithm immediately after the <a data-cite="!HTML/#transfer-receiving-steps">transfer-receiving steps</a>.</p>
    </div>
  </section>
</section>
<section id="rtpHeaderEncryption">
     <h3>RTP Header Extension Encryption</h3>
<section id="rtpHeaderEncryptionPolicy">
     <h3>
        <dfn>RTCRtpHeaderEncryptionPolicy</dfn> Enum
     </h3>
     <p>
       RTP header extension encryption policy affects whether RTP header extension
       encryption is negotiated if the remote endpoint does not support [[CRYPTEX]].
       If the remote endpoint supports [[CRYPTEX]], all media streams are sent
       utilizing [[CRYPTEX]].
     </p>
     <div>
         <pre id="target-rtp-header-encryption-policy" class="idl">enum RTCRtpHeaderEncryptionPolicy {
"negotiate",
"require"
};</pre>
      <table data-link-for="RTCRtpHeaderEncryptionPolicy" data-dfn-for=
      "RTCRtpHeaderEncryptionPolicy" class="simple">
        <tbody>
          <tr>
            <th colspan="2">Enumeration description (non-normative)</th>
          </tr>
          <tr>
            <td><dfn data-idl>negotiate</dfn></td>
            <td>
              <p>
                Negotiate RTP header extension encryption as defined in [[CRYPTEX]].
                If encryption cannot be negotiated, RTP header extensions are sent in
                the clear.
              <p>
            </td>
          </tr>
          <tr>
            <td><dfn data-idl>require</dfn></td>
            <td>
              <p>
                Require RTP header extension encryption. In [[WEBRTC]] Section 4.4.1.5, add the
                following check after Step 4.4.4:
                If <var>remote</var> is <code>true</code>, the <var>connection</var>'s
                {{RTCRtpHeaderEncryptionPolicy}} is {{RTCRtpHeaderEncryptionPolicy/require}}
                and the description does not support [[CRYPTEX]], then [= reject =] <var>p</var>
                with a newly [= exception/created =] {{InvalidAccessError}} and abort these steps.
              </p>
            </td>
          </tr>
        </tbody>
      </table>
    </div>
  </section>
  <section id="transceiver">
    <h3>
      {{RTCRtpTransceiver}} extensions
    </h3>
      <p>
         {{RTCRtpTransceiver/rtpHeaderEncryptionNegotiated}} defines whether
         the transceiver is sending enrypted RTP header extensions as defined in
         [[CRYPTEX]].
      </p>
      <div>
 <pre class="idl">
partial interface RTCRtpTransceiver {
  readonly attribute boolean rtpHeaderEncryptionNegotiated;
};</pre>
    <section>
       <h2>
         Attributes
       </h2>
       <dl data-link-for="RTCRtpTransceiver" data-dfn-for=
       "RTCRtpTransceiver" class="attributes">
       <dt>
         <dfn id="dom-rtptransceiver-rtpHeaderEncryptionNegotiated">rtpHeaderEncryptionNegotiated</dfn> of type <span class=
                "idlAttrType">Boolean</span>, readonly, nullable
        </dt>
        <dd>
         <p>
             The {{rtpHeaderEncryptionNegotiated}} attribute indicates whether [[CRYPTEX]] has been
             negotiated.  On getting, the attribute MUST
             return the value of the {{RTCRtpTransceiver/[[RtpHeaderEncryptionNegotiated]]}} slot.
             In [[WEBRTC]] Section 5.4, add the following step to "create an {{RTCRtpTransceiver}}":
             Let <var>transceiver</var> have a <dfn data-dfn-for="RTCRtpTransceiver">[[\RtpHeaderEncryptionNegotiated]]</dfn>
             internal slot, initialized to <code>false</code>.
          </p>
        </dd>
       </dl>
     </section>
  </section>
  <section id="configuration">
    <h3>
      {{RTCConfiguration}} extensions
    </h3>
          <p>
            {{RTCConfiguration/rtpHeaderEncryptionPolicy}} defines the
            policy for negotiation of RTP header encryption using
            [[CRYPTEX]].
          </p>
          <div>
            <pre class="idl">partial dictionary RTCConfiguration {
  RTCRtpHeaderEncryptionPolicy rtpHeaderEncryptionPolicy = "negotiate";
};</pre>
      <section>
              <h2>
                Dictionary {{RTCConfiguration}} Members
              </h2>
              <dl data-link-for="RTCConfiguration" data-dfn-for=
              "RTCConfiguration" class="dictionary-members">
              <dt>
                <dfn data-idl="">rtpHeaderEncryptionPolicy</dfn> of type <span class=
                "idlMemberType">RTCRtpHeaderEncryptionPolicy</span>
              </dt>
              <dd>
                <p class="needs-test">
                </p>
                <div class="issue atrisk">
                  <p>
                    {{RTCConfiguration/rtpHeaderEncryptionPolicy}} is marked
                    as a feature at risk, since there is no clear commitment
                    from implementers.
                  </p>
                </div>
              </dd>
            </dl>
       </section>
  </section>
</section>
<section id="disable-hardware">
  <h2>Disabling hardware acceleration</h2>
  <p>
    While hardware acceleration of video encoding and decoding is generally desirable, it has proven to be
    operationally challenging to achieve in the environment of a browser with no detailed information about
    the underlying hardware. In some cases, falling back to software encoding yields better results.
  <p>
  <p class="note">
    The methods specified in this section should be used sparingly and not for extended amounts of time.
   </p>
  <p class="note">
    In privacy-sensitive contexts, browsers may disable hardware acceleration by default to
    reduce the fingerprinting surface.
  </p>
  <h3>
    {{RTCRtpReceiver}} extensions
  </h3>
  <p>
    The {{RTCRtpReceiver}} interface is defined in [[WEBRTC]]. This document extends this interface
    by adding a static method and internal slot
    <dfn data-dfn-for=RTCRtpReceiver>{{RTCRtpReceiver/[[HardwareDisabled]]}}</dfn> initialized to <code>false</code>.
  </p>
  <pre class="idl">partial interface RTCRtpReceiver {
    static undefined disableHardwareDecoding();
};
</pre>
  <p>When the {{RTCRtpReceiver}}'s disableHardwareDecoding method is called, the user agent MUST run the following steps:</p>
  <ol>
    <li>
      <p>When the <code>RTCPeerConnection.constructor()</code> has been invoked abort these steps.</p>
    </li>
    <li>
      <p>Set the RTCRtpReceiver's {{RTCRtpReceiver/[[HardwareDisabled]]}} slot to <code>true</code>.</p>
    </li>
  </ol>
  <h3>
    {{RTCRtpSender}} extensions
  </h3>
  <p>
    The {{RTCRtpSender}} interface is defined in [[WEBRTC]]. This document extends this interface
    by adding a static method and internal slot
    <dfn data-dfn-for=RTCRtpSender>{{RTCRtpSender/[[HardwareDisabled]]}}</dfn> initialized to <code>false</code>.
  </p>
  <pre class="idl">partial interface RTCRtpSender {
    static undefined disableHardwareEncoding();
};
</pre>
  <p>When the {{RTCRtpSender}}'s disableHardwareEncoding method is called, the user agent MUST run the following steps:</p>
  <ol>
    <li>
      <p>When the <code>RTCPeerConnection.constructor()</code> has been invoked abort these steps.</p>
    </li>
    <li>
      <p>Set the RTCRtpSender's {{RTCRtpSender/[[HardwareDisabled]]}} slot to <code>true</code>.</p>
    </li>
  </ol>
  <h3>Modifications to existing procedures</h3>
  <p>
    In the <a data-cite="WEBRTC#set-description">set a session description</a> algorithm, add a step
    right after the step that sets transceiver.[[\Receiver]].[[\ReceiveCodecs]],
    saying "If the RTCRtpReceiver's {{RTCRtpReceiver/[[HardwareDisabled]]}} slot is <code>true</code>,
    remove any codec from transceiver.[[\Receiver]].[[\ReceiveCodecs]] for which the underlying decoder
    is hardware-accelerated".
  </p>
  <p>
    In the <a data-cite="WEBRTC#set-description">set a session description</a> algorithm, add a step
    right after the step that sets transceiver.[[\Sender]].[[\SendCodecs]],
    saying "If the RTCRtpSender's {{RTCRtpSender/[[HardwareDisabled]]}} slot is <code>true</code>,
    remove any codec from transceiver.[[\Sender]].[[\SendCodecs]] for which the underlying encoder
    is hardware-accelerated".
  </p>
</section>
<section id="removed-features">
    <h3>Removed features</h3>
    <p>
      This section documents features that were moved from [[WEBRTC]] to this extension
      specification due to lack of support from implementers.
    </p>
  <section id="removed-rtcpeerconnection-features">
    <h3>
      {{RTCPeerConnection}} extensions
    </h3>
    <p>
      The {{RTCPeerConnection}}
      interface is defined in [[WEBRTC]]. This document extends that interface
      by adding an additional static method.
    </p>
    <pre class="idl">partial interface RTCPeerConnection {
  static sequence&lt;RTCIceServer&gt; getDefaultIceServers();
};</pre>
    <section>
      <h2>Methods</h2>
      <dl data-link-for="RTCPeerConnection" data-dfn-for=
      "RTCPeerConnection" class="methods">
        <dt><dfn data-idl>getDefaultIceServers</dfn></dt>
        <dd>
          <p>Returns a list of ICE servers that are configured into the
          browser. A browser might be configured to use local or private
          STUN or TURN servers. This method allows an application to learn
          about these servers and optionally use them.</p>
          <p class="fingerprint">This list is likely to be persistent and
          is the same across origins. It thus increases the
          fingerprinting surface of the browser. In privacy-sensitive
          contexts, browsers can consider mitigations such as only
          providing this data to whitelisted origins (or not providing it
          at all.)</p>
          <p class="note">Since the use of this information is left to
          the discretion of application developers, configuring a user
          agent with these defaults does not per se increase a user's
          ability to limit the exposure of their IP addresses.</p>
          <p class="note">If set, the configured default ICE servers exposed by
          {{RTCPeerConnection/getDefaultIceServers}} on
          {{RTCPeerConnection}} instances provides persistent
          information across time and origins which increases the fingerprinting
          surface of a given browser.</p>
          <div class="issue atrisk">
            <p>
              {{RTCPeerConnection/getDefaultIceServers()}} was moved from [[WEBRTC]] to
              this specification due to lack of support from implementers and concerns
              discussed in <a href="https://github.com/w3c/webrtc-pc/issues/2023">webrtc-pc#2023</a>.
            </p>
          </div>
        </dd>
      </dl>
    </section>
  </section>
  <section id="rtcicecredentialtype-enum">
    <h3>
      {{RTCIceCredentialType}} extensions
    </h3>
    <p>The following enum values are added to the
    {{RTCIceCredentialType}}
    enum defined in [[WEBRTC]].</p>
    <div>
        <pre class="idl"
>// This is a partial enum, but this is not yet expressable in WebIDL.
enum RTCIceCredentialType {
    "oauth"
};</pre>
    <table data-link-for="RTCIceCredentialType" data-dfn-for=
    "RTCIceCredentialType" class="simple">
      <tbody>
        <tr>
          <th colspan="2">Enumeration description</th>
        </tr>
        <tr>
          <td><dfn data-idl>oauth</dfn></td>
          <td><p>An OAuth 2.0 based authentication method, as described
          in [[RFC7635]].
          </p>
          <p>For OAuth Authentication, the <a data-cite="WEBRTC#dfn-ice-agent">ICE Agent</a> requires three
          pieces of credential information. The credential is composed of
          a <code>kid</code>, which the {{RTCIceServer.username}} member is used for, and
          <code>macKey</code> and <code>accessToken</code>, which are
          placed in the {{RTCOAuthCredential}} dictionary.
          </p>
          <p class="note">
          This specification does not define how an application (acting
          as the [=OAuth Client=]) obtains the
          <code>accessToken</code>, <code>kid</code> and
          <code>macKey</code> from the [=Authorization Server=], as
          WebRTC only handles the interaction between the <a data-cite="WEBRTC#dfn-ice-agent">ICE
          Agent</a> and TURN server. For example, the application may use
          the OAuth 2.0 Implicit Grant type, with PoP (Proof-of-Possession)
          Token type, as described in [[RFC6749]] and
          [[OAUTH-POP-KEY-DISTRIBUTION]]; an example of this is provided
          in [[RFC7635]], Appendix B.</p>
          <p>
          The application, acting as the <a>OAuth Client</a>, is responsible for
          refreshing the credential information and updating the <a data-cite="WEBRTC#dfn-ice-agent">ICE
          Agent</a> with fresh new credentials before the
          <code>accessToken</code> expires. The <a>OAuth Client</a> can use the
          {{RTCPeerConnection.setConfiguration()}}
          method to periodically refresh the TURN credentials.</p>
          <p>The length of the HMAC key
          ({{RTCOAuthCredential.macKey}}) MAY be any integer
          number of bytes greater than 20 (160 bits).</p>
          <p class="note">According to [[RFC7635]] Section 4.1, the
          HMAC key MUST be a symmetric key, as asymmetric keys would
          result in large access tokens which may not fit in a single
          STUN message.</p>
          <p class="note">Currently the STUN/TURN protocols use only SHA-1 and SHA-2
          family hash algorithms for Message Integrity Protection, as
          defined in [[RFC5389]] Section 15.4, and [[STUN-BIS]]
          Section 14.6.</p>
          <p>When <a
          data-cite="WEBRTC#set-pc-configuration">setting a
          configuration</a> and evaluating urls, also run the following step:
          <ol>
            <li>
              <p>If <var>scheme name</var> is <code>turn</code> or
              <code>turns</code>, and
              <code><var>server</var>.{{RTCIceServer/credentialType}}</code> is
              <code>"oauth"</code>, and
              <code><var>server</var>.{{RTCIceServer/credential}}</code> is not an
              {{RTCOAuthCredential}}, then [=exception/throw=] an
              {{InvalidAccessError}}.</p>
            </li>
          </ol>
          <div class="issue atrisk">
            <p>
              The {{RTCIceCredentialType/"oauth"}} value of {{RTCIceCredentialType}}
              was moved from [[WEBRTC]] to this specification due to lack of support
              from implementers. It is therefore marked as a feature at risk.
            </p>
          </div>
          </td>
        </tr>
      </tbody>
    </table>
    </div>
  </section>
  <section>
    <h3>
      <dfn>RTCOAuthCredential</dfn> Dictionary
    </h3>
    <p>The {{RTCOAuthCredential}} dictionary is used to describe
    the OAuth auth credential information which is used by the STUN/TURN
    client (inside the <a data-cite="WEBRTC#dfn-ice-agent">ICE Agent</a>) to authenticate against a STUN/TURN
    server, as described in [[RFC7635]]. Note that the <code>kid</code>
    parameter is not located in this dictionary, but in
    {{RTCIceServer.username}} member.</p>
    <div class="issue atrisk">
      <p>
         The {{RTCOAuthCredential}} dictionary was moved from [[WEBRTC]] to
         this specification due to lack of support from implementers. It is
         therefore marked as a feature at risk.
      </p>
    </div>
    <div>
      <pre class="idl"
>dictionary RTCOAuthCredential {
    required DOMString macKey;
    required DOMString accessToken;
};</pre>
      <section>
        <h2>Dictionary {{RTCOAuthCredential}} Members
        </h2>
        <dl data-link-for="RTCOAuthCredential" data-dfn-for="RTCOAuthCredential"
        class="dictionary-members">
          <dt><dfn data-idl>macKey</dfn> of type <span class=
          "idlMemberType">DOMString</span>, required</dt>
          <dd>
            <p>The "mac_key", as described in [[RFC7635]], Section 6.2, in
            a base64-url encoded format. It is used in STUN message
            integrity hash calculation (as the password is used in password
            based authentication). Note that the OAuth response "key"
            parameter is a JSON Web Key (JWK) or a JWK encrypted with a JWE
            format. Also note that this is the only OAuth parameter whose
            value is not used directly, but must be extracted from the "k"
            parameter value from the JWK, which contains the needed
            base64-encoded "mac_key".</p>
          </dd>
          <dt><dfn data-idl>accessToken</dfn> of type <span class=
          "idlMemberType">DOMString</span>, required</dt>
          <dd>
            <p>The "access_token", as described in [[RFC7635]], Section
            6.2, in a base64-encoded format. This is an encrypted
            self-contained token that is opaque to the application.
            Authenticated encryption is used for message encryption and
            integrity protection. The access token contains a non-encrypted
            nonce value, which is used by the Authorization Server for unique
            mac_key generation. The second part of the token is protected
            by Authenticated Encryption. It contains the mac_key, a
            timestamp and a lifetime. The timestamp combined with lifetime
            provides expiry information; this information describes the
            time window during which the token credential is valid and
            accepted by the TURN server.
            </p>
          </dd>
       </dl>
      </section>
    </div>
    <p>An example of an RTCOAuthCredential dictionary is:</p>
    <pre class="example highlight">
<code>{
  macKey: 'WmtzanB3ZW9peFhtdm42NzUzNG0=',
  accessToken: 'AAwg3kPHWPfvk9bDFL936wYvkoctMADzQ5VhNDgeMR3+ZlZ35byg972fW8QjpEl7bx91YLBPFsIhsxloWcXPhA=='
}</code></pre>
  </section>
  <section id="rtciceserver-dictionary">
    <h3>
      {{RTCIceServer}} extensions
    </h3>
    <p>
      The {{RTCIceServer}}
      dictionary is defined in [[WEBRTC]]. This document extends that
      dictionary by adding the {{RTCIceServer/credential}} attribute, and adds a
      paragraph to how to interpret the existing {{RTCIceServer/username}}
      attribute.
    </p>
    <pre class="idl"
>partial dictionary RTCIceServer {
    // This attribute is not new in this extension spec, but how to interpret it
    // in the case of credentialType being "oauth" is described here.
    DOMString username;
    (DOMString or RTCOAuthCredential) credential;
};</pre>
    <h2>Dictionary {{RTCIceServer}} Members</h2>
    <dl data-link-for="RTCIceServer" data-dfn-for="RTCIceServer" class=
    "dictionary-members">
      <dt><dfn data-idl>username</dfn> of type {{DOMString}}</dt>
      <dd>
        <p>How to interpret the {{username}} when this
        {{RTCIceServer}} object represents a TURN server, and
        {{RTCIceServer/credentialType}} is {{RTCIceCredentialType/"password"}} is specified
        in {{RTCIceServer}} of [[WEBRTC]].</p>
        <p>If this {{RTCIceServer}} object represents a
        TURN server, and {{RTCIceServer/credentialType}} is
        {{RTCIceCredentialType/"oauth"}}, then this attribute specifies the Key ID
        (<code>kid</code>) of the shared symmetric key, which is shared
        between the TURN server and the Authorization Server, as described
        in [[RFC7635]]. It is an ephemeral and unique key identifier.
        The <code>kid</code> allows the TURN server to select the
        appropriate keying material for decryption of the Access-Token,
        so the key identified by this <code>kid</code> is used in the
        Authenticated Encryption of the "access_token". The
        <code>kid</code> value is equal with the OAuth response "kid"
        parameter, as defined in [[RFC7515]] Section 4.1.4.</p>
      </dd>
      <dt><dfn data-idl>credential</dfn> of type <span class=
      "idlMemberType">(DOMString or {{RTCOAuthCredential}})
      </span></dt>
      <dd>
        <p>If this {{RTCIceServer}} object represents a
        TURN server, then this attribute specifies the credential to
        use with that TURN server.</p>
        <p>If {{RTCIceServer/credentialType}} is {{RTCIceCredentialType/"password"}},
        {{credential}} is a DOMString, and represents a
        long-term authentication password, as described in
        [[RFC5389]], Section 10.2.</p>
        <p>If {{RTCIceServer/credentialType}} is {{RTCIceCredentialType/"oauth"}},
        {{credential}} is an {{RTCOAuthCredential}}, which
        contains the OAuth access token and MAC key.</p>
        <p>If this {{RTCIceServer}} object represents a
        TURN server, and {{RTCIceServer/credentialType}} is
        {{RTCIceCredentialType/"oauth"}}, then this attribute specifies the Key ID
        (<code>kid</code>) of the shared symmetric key, which is shared
        between the TURN server and the Authorization Server, as described
        in [[RFC7635]]. It is an ephemeral and unique key identifier.
        The <code>kid</code> allows the TURN server to select the
        appropriate keying material for decryption of the Access-Token,
        so the key identified by this <code>kid</code> is used in the
        Authenticated Encryption of the "access_token". The
        <code>kid</code> value is equal with the OAuth response "kid"
        parameter, as defined in [[RFC7515]] Section 4.1.4.</p>
       <div class="issue atrisk">
         <p>
            The {{RTCIceServer/credential}} attribute was moved from [[WEBRTC]] to
            this specification due to lack of support from implementers. It is
            therefore marked as a feature at risk.
         </p>
       </div>
      </dd>
    </dl>
    <p>An example array of {{RTCIceServer}} objects is:</p>
    <pre class="example highlight">
<code>{
  urls: 'turns:turn2.example.net',
  username: '22BIjxU93h/IgwEb',
  credential: {
    macKey: 'WmtzanB3ZW9peFhtdm42NzUzNG0=',
    accessToken: 'AAwg3kPHWPfvk9bDFL936wYvkoctMADzQ5VhNDgeMR3+ZlZ35byg972fW8QjpEl7bx91YLBPFsIhsxloWcXPhA=='
  },
  credentialType: 'oauth'
}</code></pre>
  </section>
    <section>
    <h3>
      {{RTCRtpSynchronizationSource}} extensions
    </h3>
    <p>This document extends {{RTCRtpSynchronizationSource}} with a {{RTCRtpSynchronizationSource/voiceActivityFlag}} member (initially defined in the WebRTC 1.0 specification but later dropped due to lack of implementation).</p>
  <pre class="idl">
    partial dictionary RTCRtpSynchronizationSource {
    boolean voiceActivityFlag;
    };</pre>
              <dl data-link-for="RTCRtpSynchronizationSource" data-dfn-for=
            "RTCRtpSynchronizationSource" class="dictionary-members">
              <dt>
                <dfn data-idl="">voiceActivityFlag</dfn> of type <span class=
                "idlMemberType">boolean</span>
              </dt>
              <dd>
                <p class="needs-test">
                  Only present for audio receivers. Whether the last RTP
                  packet, delivered from this source, contains voice activity
                  (true) or not (false). If the RFC 6464 extension header was
                  not present, or if the peer has signaled that it is not using
                  the V bit by setting the "vad" extension attribute to "off",
                  as described in [[!RFC6464]], Section 4,
                  {{voiceActivityFlag}} will be absent.
                </p>
                <div class="issue atrisk">
                  <p>
                    {{RTCRtpSynchronizationSource/voiceActivityFlag}} was moved from [[WEBRTC]] to
                    this specification due to lack of support from implementers. It is therefore
                    marked as a feature at risk.
                  </p>
                </div>
              </dd>
            </dl>
   </section>
  </section>
<section class="informative">
    <h2>
      Security Considerations
    </h2>
      <p>
        This section is non-normative; it specifies no new behaviour.
        The overall security considerations of the general set
        of APIs and protocols used in WebRTC are described in
        [[?RFC8827]].
      </p>
      <section>
        <h2>
          Impact on local network
        </h2>
        <p>
          The extensions defined in this document do not provide
          additional impact on the local network beyond what is described in
          [[WEBRTC]] Section 13.3.
        </p>
      </section>
      <section>
        <h2>
          Confidentiality of Communications
        </h2>
        <p>
          This document defines extensions for encryption of RTP Header Extensions which
          improve the confidentiality of communications by encrypting header extension
          IDs, as well as CSRCs.
        </p>
      </section>
</section>
<section class="informative">
    <h2>
      Privacy Considerations
    </h2>
      <p>
        This section is non-normative; it specifies no new behaviour.
      </p>
      <section>
        <h2>
          Revealing IP addresses
        </h2>
        <p>
          The extensions defined in this document do not reveal additional
          information on IP addresses beyond that already described in
          [[WEBRTC]] Section 13.2.
        </p>
      </section>
      <section>
        <h2>
          Persistent information exposed by WebRTC
        </h2>
        <p>
          The extensions defined in this document do not provide additional
          persistent information beyond that which is discussed in [[WEBRTC]]
          Section 13.5.
        </p>
      </section>
</section>
<section class="informative">
      <h2>
        Accessibility Considerations
      </h2>
      <p>
        The WebRTC 1.0 specification exposes an API to control protocols
        (defined within the IETF) necessary to establish real-time audio, video
        and data exchange. Real-Time Text, defined in [[RFC4103]], is supported
        via the data channel API as described in [[WEBRTC]] Section 14. The
        extensions defined in this document do not affect support for Real-Time
        Text.
      </p>
</section>
<section class="appendix">
    <h2>Acknowledgements</h2>
    <p>
      The editors wish to thank the Working Group chairs and Team Contact,
      Dominique Hazal-Massieux, for their support. Substantial text in this
      specification was provided by many people including
      Harald Alvestrand, Justin Uberti and Peter Thatcher.
    </p>
    <p>
      The {{RTCRtpSender}} and {{RTCRtpReceiver}} objects were initially
      described in the <a href="https://www.w3.org/community/ortc/">W3C ORTC
      CG</a>, and have been adapted for use in this specification.
    </p>
</section>
</body>
</html>
